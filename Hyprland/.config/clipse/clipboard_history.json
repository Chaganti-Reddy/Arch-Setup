{"clipboardHistory":[{"value":"src=\"https://megacloud.tube/embed-1/e-1/74yheM7k6e8I?autoPlay=0\"","recorded":"2024-10-24 22:37:04.349279158","filePath":"null","pinned":false},{"value":"https://archive.org/download/moonfall-60fps-dualgb/moonfall-60fps-dualgb_archive.torrent","recorded":"2024-10-24 22:24:16.007383104","filePath":"null","pinned":false},{"value":"https://archive.org/download/moonfall-60fps-dualgb/Moonfall60fpsDUALGB.mpv","recorded":"2024-10-24 22:23:51.659750878","filePath":"null","pinned":false},{"value":"There are different techniques that are used for the diagnosis of oral cancer, a few of the clinical techniques used by doctors are discussed below:\n\n\\textbf{Barium Swallow:} The voice box, throat, and surroundings may display abnormalities during a barium swallow test, which is also frequently used to find small, early oral tumors.\n\n\\textbf{Biopsy:} The initial step in identifying mouth cancer is an oral tissue biopsy. A small amount of abnormal tissue from the area where oral cancer is suspected is removed by the surgeon during the biopsy. An oral cancer diagnosis may be confirmed by biopsy. The following types of biopsies are frequently used to identify oral carcinoma:\n\n\\begin{itemize}\n    \\item \\textbf{Incisive biopsies:} The region has a small amount of tissue taken from it that appears to be abnormal. If the abnormal location is easily accessible, the specimen could be obtained at the office of a doctor. If the cancer is more deeply embedded in the mouth or throat, biopsy procedures might have to be carried out in a surgical theatre while receiving anesthesia in order to lessen pain.\n    \n    \\item \\textbf{Exfoliative cytology:} Cell samples are gently scraped from a questionable location. To make the cells visible under a microscope, they are placed on a transparent slide and subsequently colored. A deeper biopsy will be done if any cells seem suspicious.\n\\end{itemize}\n\n\\textbf{Image-based tests:}\n\n\\begin{itemize}\n    \\item \\textbf{Computerized Tomography (CT) Scan:} Information on the size, shape, and location of any tumors can be obtained via a CT scan, which can help detect lymph nodes that are bulging and may contain cancer cells.\n    \n    \\item \\textbf{Magnetic Resonance Imaging (MRI):} Oral cancer may be examined with an MRI scan, although this is less usual. MRIs give a very detailed picture and may be very helpful in figuring out whether other areas of the body, such as the neck, have been affected by the disease's spread.\n    \n    \\item \\textbf{Positron Emission Tomography (PET):} Patients with cancer of the oral cavity might get a scan using PET technology to determine if the disease has migrated to the lymph nodes or has recently progressed to that location.\n    \n    \\item \\textbf{Genomic Testing for Advanced Oral Cancer:} Genomic testing, sometimes known as molecular profiling or cancer sequencing, involves examining the collected cells from a biopsy to check for any genetic mutations (changes in DNA) that might be connected to the person’s specific type of cancer.\n\\end{itemize}\n","recorded":"2024-10-24 16:39:18.468177891","filePath":"null","pinned":false},{"value":"There are different techniques that are used for the diagnosis of oral cancer, few of the\nclinical techniques used by doctors are discussed below :-\nBarium Swallow: - The voice box, the throat, referral, and surroundings may display\nabnormalities during a barium swallow test, which is also frequently used to find small,\nearly oral tumors.\nBiopsy: - The initial step in identifying mouth cancer is an oral tissue biopsy. A little bit\nof aberrant tissue from the area where oral cancer is suspected is removed by the surgeon\nduring the biopsy. An oral cancer diagnosis may be confirmed by biopsy. The following\ntypes of biopsies are frequently used to identify oral carcinoma:\n• Incisive biopsies: The region has a small amount of tissue taken from it that appears\nto be abnormal. If the abnormal location is easily accessible, the specimen could\nbe obtained at the office of a doctor. If the cancer is more deeply embedded in the\nmouth or throat, biopsy procedures might have to be carried out in a surgical theatre\nwhile receiving anesthesia in order to lessen pain.\n• Exfoliative cytology: Cell samples are gently scraped from a questionable loca-\ntion. To make the cells visible under a microscope, they are put upon a transparent\n4\nslide, and subsequently colored. A deeper biopsy will be done if any cells seem\nsuspicious.\nImage-based tests\n• Computerized Tomography, or CT, Scanning – Information on the size, shape, and\nlocation of any tumors can be obtained via a CT scan, which can help detect lymph\nnodes that are bulging that may contain cancer cells.\n• Magnetic Resonance Imaging (MRI): Oral cancer may be examined with an MRI\nscan, although this is less usual. MRIs give a very thorough picture and may be\nvery helpful in figuring out whether other areas of the body, such as the neck, have\nbeen affected by the disease’s spread.\n• Positron emission computed tomography (PET): Patients with cancer of the oral\ncavity might get a scan using PET technology to find out whether the disease has\nmigrated to the lymph nodes or whether it has only recently progressed to that\nlocation.\n• Genomic testing for advanced oral cancer: -Genomic testing is sometimes known as\nmolecular profiling or cancer sequencing. Examining the collected cells is required\n8 from a biopsy in order to check for any genetic mutations (changes in your DNA)\nthat might be connected to the person’s particular type of cancer.","recorded":"2024-10-24 16:36:34.237729235","filePath":"null","pinned":false},{"value":"/home/karna/Pictures/Screenshots/mouth structure.png","recorded":"2024-10-24 14:44:02.307887243","filePath":"null","pinned":false},{"value":"The Mandible (Lower Jawbone)","recorded":"2024-10-24 14:42:09.927807496","filePath":"null","pinned":false},{"value":"Teeth, gums, and alveolar ridge, which is the ridge-like border of the jaws that\ncontains the tooth sockets.","recorded":"2024-10-24 14:41:53.330676270","filePath":"null","pinned":false},{"value":"The roof of the mouth","recorded":"2024-10-24 14:41:48.149986970","filePath":"null","pinned":false},{"value":"The buccal mucosa, which coats the cheekbones’ interior","recorded":"2024-10-24 14:41:37.876343214","filePath":"null","pinned":false},{"value":"The Uvula and the Tongue","recorded":"2024-10-24 14:41:31.764317912","filePath":"null","pinned":false},{"value":"The Tonsils and The Soft Palate","recorded":"2024-10-24 14:30:07.501523361","filePath":"null","pinned":false},{"value":"The Lips","recorded":"2024-10-24 14:29:37.758953009","filePath":"null","pinned":false},{"value":"The human mouth commences at the junction of the lips and skin. Figure 1.1 illustrates the anatomy of the human oral cavity. The palette consists of both hard and soft components. The soft palate separates the mouth from the nasopharynx, the upper segment of the pharynx, which is linked to the mouth through the oropharynx, the middle region of the pharynx. The lateral aspects of the mouth are constituted by the inner surface of the cheeks (De Angeli et al. 2022). The tongue occupies the majority of the floor of the mouth.\nThe mouth can be categorized into several components, including:","recorded":"2024-10-24 14:29:14.604650366","filePath":"null","pinned":false},{"value":"The start of the human mouth is where the lips and skin converge Figure 1.1 shows the\nstructure of the human mouth. The roof of the mouth is made up of both hard and soft\npalates. A soft palate divides the mouth from the nasopharynx (the upper part of the\npharynx), which is connected to the mouth via the oropharynx (the middle section of the\npharynx). The sides of the mouth are formed by the cheeks’ inner surface (De Angeli et\nal. 2022). The majority of the mouth’s floor, or lowest portion, is occupied by the tongue.\nThe mouth can be divided into various sections, including-:","recorded":"2024-10-24 14:29:03.166788082","filePath":"null","pinned":false},{"value":"/mnt/Media/Magician Launcher.app\n/mnt/Media/Magician Launcher.exe\n/mnt/Media/RootCA.crt","recorded":"2024-10-24 14:10:33.155916880","filePath":"null","pinned":false},{"value":"/run/media/karna/T7/Magician Launcher.app\n/run/media/karna/T7/Magician Launcher.exe\n/run/media/karna/T7/RootCA.crt","recorded":"2024-10-24 14:08:36.993377931","filePath":"null","pinned":false},{"value":"Mutations in the cells of the mouth or lips lead to the development of oral carcinomas. DNA contains the directives for cellular functions. When typically functioning cells would perish, modifications induce the persistent proliferation and division of the cells. The anomalous oral carcinoma cells might aggregate into a neoplasm. Eventually, they may disseminate from the oral cavity throughout the entire body, encompassing the neck and other regions of the head.\nMouth cancers typically originate in the flat, thin squamous cells that comprise the surface of the lips and the interior of the mouth. Oral cancer is predominantly induced by squamous cell carcinomas.","recorded":"2024-10-24 13:56:56.620897761","filePath":"null","pinned":false},{"value":"When DNA alterations (mutations) occur in the mouth or lip cells, mouth carcinomas de-\nvelop. DNA includes the instructions for what the cell must accomplish. When normally\nfunctioning cells would die, alterations cause the continued growth and division of the\ncells. The aberrant mouth cancer cells can assemble into a tumor. In time, they might\nspread from the inside of the mouth to the whole body, including the neck or various parts\nof the head.\nMouth cancers tend to start in the flat, thin cells (squamous cells) which define the sur-\nface of the lips and the interior of the mouth. Oral cancer is most frequently caused by\nsquamous cell tumors.","recorded":"2024-10-24 13:56:40.926593375","filePath":"null","pinned":false},{"value":"Cancer can develop in the lips, tongue, inner lining of the cheek, gums, mouth, and the hard and soft palate.","recorded":"2024-10-24 13:55:22.507309735","filePath":"null","pinned":false},{"value":"The following organs can develop cancer:\n\\begin{enumerate}\n    \\item Lips\n    \\item Tongue\n    \\item Inner lining of the cheek\n    \\item Gums\n    \\item Mouth Cancer\n    \\item Hard and Soft Palate\n\\end{enumerate}","recorded":"2024-10-24 13:55:00.043487526","filePath":"null","pinned":false},{"value":"Painful or arduous deglutition","recorded":"2024-10-24 13:54:40.201201929","filePath":"null","pinned":false},{"value":"A growth or protrusion within the oral cavity; mobility of teeth; • Painful or arduous deglutition","recorded":"2024-10-24 13:54:33.615566190","filePath":"null","pinned":false},{"value":"An oral or labial ulcer that remains unhealed","recorded":"2024-10-24 13:54:26.320951419","filePath":"null","pinned":false},{"value":"An intraoral lesion that is either white or red","recorded":"2024-10-24 13:54:20.249709675","filePath":"null","pinned":false},{"value":"An internal mouth patch that is either white or red","recorded":"2024-10-24 13:54:04.870851335","filePath":"null","pinned":false},{"value":"A mouth or lip sore that does not heal","recorded":"2024-10-24 13:53:57.931914779","filePath":"null","pinned":false},{"value":"Mouth cancer, commonly referred to as oral cancer, happens whenever a tumor forms\ninside the mouth lining. It could be located on the surface of the tongue, the interior of\nthe cheeks, the palate, the lips themselves, or the gums. Additionally, the glands that\ncreate tumors saliva, the tonsils in the rear within the mouth. But these occur frequently.\nSymptoms of mouth cancer:","recorded":"2024-10-24 13:53:22.116184847","filePath":"null","pinned":false},{"value":"Mouth cancer, or oral cancer, occurs when a tumor develops within the lining of the mouth. It may be situated on the tongue's surface, the inner cheeks, the palate, the lips, or the gums. Furthermore, the glands responsible for saliva production, specifically the tonsils located at the posterior region of the oral cavity, might develop malignancies. However, these events transpire with regularity.\nManifestations of oral cancer:","recorded":"2024-10-24 13:53:13.703937480","filePath":"null","pinned":false},{"value":"Mouth cancer, commonly referred to as oral cancer, happens whenever a tumor forms\ninside the mouth lining. It could be located on the surface of the tongue, the interior of\nthe cheeks, the palate, the lips themselves, or the gums. Additionally, the glands that\ncreate tumors saliva, the tonsils in the rear within the mouth. But these occur frequently.\nSymptoms of mouth cancer:\n• A mouth or lip sore that does not heal\n• An internal mouth patch that is either white or red\n• A growth or bulge inside your mouth; loose teeth;\n• Painful or difficult swallowing","recorded":"2024-10-24 13:52:47.918901975","filePath":"null","pinned":false},{"value":"\\subsection{Oral Cancer} \\label{sec-01.01}","recorded":"2024-10-24 13:52:24.180689948","filePath":"null","pinned":false},{"value":"The following organs can develop cancer:\n• Lips\n• Tongue\n• Inner lining of the cheek\n• Gums\n• Mouth Cancer\n• Hard and Soft Palate","recorded":"2024-10-24 13:34:22.098787690","filePath":"null","pinned":false},{"value":"Type of Oral Cancer","recorded":"2024-10-24 13:33:12.677862193","filePath":"null","pinned":false},{"value":"The cells of the mouth are the initial sites of oral cancer development. A malignant nodule is a cluster of cancer cells capable of infiltrating adjacent tissue and causing significant harm. It can also metastasis to various regions of the body. The lymph nodes in the neck are the primary sites for the metastasis of oral cancer. Oral cancer is also known as mouth cancer. Occasionally, oral cells undergo alterations that impede their growth or correct functioning. These modifications may lead to benign malignancies such as warts and fibromas. Precancerous conditions may also be induced by alterations in the cells of the oral cavity. This suggests that while the aberrant cells are currently not cancerous, there exists a possibility that they may progress to cancer if left untreated. Leukoplakia and erythroplakia are two of the most common precancerous conditions of the oral cavity.\nOral cancer may, however, occasionally arise from modifications to the cellular architecture of the mouth. The oral mucosa is a mucosal membrane that lines the oral cavity. The squamous epithelium, constituting the oral mucosa, consists of squamous cells. Mouth cancer often originates in these thin, flat squamous cells. The designation for this type of malignancy is oral squamous cell carcinoma.","recorded":"2024-10-24 13:32:44.422801143","filePath":"null","pinned":false},{"value":"The mouth’s cells are the first to develop oral cancer. A cancerous (malignant) nodule is\na group of cancer cells tumor that has the ability to invade neighboring tissue and wreck\nmisery on it. It can also metastasize to different parts of the body. Nodes of lymph in\nthe neck are the part where mouth cancer spreads most frequently. Oral cancer may also\nbe referred to as mouth cancer. Sometimes, cells that are present in the mouth undergo\nchanges and will stop growing or behaving properly. These alterations could result in\nbenign (non-cancerous) tumors like warts and fibromas. Precancerous diseases can also\nbe brought on by changes in the mouth’s cells. This indicates that although the abnormal\ncells are not now cancer, there is a potential that they could develop into cancer if lefuntreated. Leukoplakia and erythroplakia are two of the most prevalent precancerous\ndisorders of the mouth.\nOral cancer can, however, occasionally result from alterations to the mouth’s cellular\nstructure. The oral mucosa (mucous membrane) is a lining that lines the mouth. The\nsquamous epithelium, which composes the oral mucosa, is made up of squamous cells.\nThese thin, flat squamous cells are where mouth cancer typically begins. The term for\nthis type of cancer is mouth squamous cell carcinoma.","recorded":"2024-10-24 13:31:23.499089763","filePath":"null","pinned":false},{"value":"Oral Cancer detection using Deep Learning","recorded":"2024-10-24 13:30:48.931760804","filePath":"null","pinned":false},{"value":"Cancer is a disease caused by abnormal cells proliferating uncontrollably within the body. A segment of the body's cells in all cancers initiates fast division and disseminates to adjacent tissues. Cancer can manifest in practically any location within the multitude of cells in the body. Typically, human cells proliferate and divide to generate new cells as needed by the body. When a cell sustains injury or reaches senescence, it ceases to function and is supplanted by a new cell. However, when cancer progresses, this systemic mechanism deteriorates.\nOld or damaged cells that ought to have perished persist, as cells increasingly become erroneous, while new cells are produced even when they are undesirable. These cells possess the capability to proliferate, potentially resulting in tumor-like formations. Solid tumors, or tissue lumps, are a prevalent kind of cancer. Leukemias and other hematologic malignancies generally do not become solid tumors.","recorded":"2024-10-24 13:29:36.710421208","filePath":"null","pinned":false},{"value":"Cancer is a disease brought on by aberrant cells when an internal component is expanding\nout of control. A portion of the body’s cells in all tumors, begin to divide rapidly and\nspread to parts of the neighboring tissues. Among the millions of cells, cancer can appear\nvirtually at any place in the body. Normally, human cells multiply and divide to produce\nnew cells as the body requires them. When a cell becomes damaged or old, it expires and\nis replaced by a fresh cell. But as cancer grows, this systematic mechanism disintegrates.\nOld or injured cells that should have died survive, as cells become more and more erro-\nneous whereas new cells are generated even when they are unwanted. These cells can\ndivide to form new ones, which may lead to tumor-like growth. Solid tumors, or masses\nof tissue, are a common kind of cancer. Leukemias and other blood cancers typically do\nnot develop solid tumors","recorded":"2024-10-24 13:27:07.852367038","filePath":"null","pinned":false},{"value":"1.7\n Deep Learning\nOne of the main components of an Artificially Intelligent system is learning. Learning\nmeans when a computer program can learn through its surrounding. Artificially intelli-\ngent systems have the ability to mimic the human brain and have the ability to process\ninformation and develop various patterns used to make decisions (Dubuc et al. 2022). A\nsub type of machine learning called \"deep learning\" in artificial intelligence (AI) allows\nnetworks to learn unsupervised from unlabelled input. Deep learning can also refer to\ndeep neural networks or deep learning.\n1.7.1\n Importance of Deep Learning\nMachine learning techniques can now build and learn from a large pool of training data\nbecause to improvements in computer speed and memory over time.\nDeep learning has been a cutting-edge method for humanity, especially when the Informa-\ntion is noisy. Artificial neural networks can learn any function with just one hidden layer,\nregardless of how ambiguous it is, which is why they are regarded as universal function\napproximations.\n7\n1.7.2\n CNN\nConvolutional neural network (CNN) is a subtype of ANN. In at least one of their layers,\nCNN’s replace conventional matrix multiplication methods with the convolution mathe-\nmatical technique. Since they were developed specifically to handle pixel data, they are\nused in image recognition and processing. The design with which CNN is built is compa-\nrable with the model of neural connection like a person’s brain (Jeyaraj, B. K. Panigrahi,\nand Samuel Nadar 2022). Because of the way CNN is built, there are some strong prefer-\nences ingrained in them, which makes it easier to comprehend why they are so effective.\nCNN can be seen as a feed-forward network but having connection with each image can\nFigure 1.3: A CNN Architecture\n(Sun et al. 2019)\nbe inefficient. Therefore, we can prune the useless connection between the hidden layers\nto increase the performance of the layer. A CNN is a special artificial neural network with\nlimited connections between the layers of artificial neural network.\n• Max-Pooling: Each feature map produced by processing the input through many\nlayers of convolution is subsequently combined in a pooling layer. Little grids are\nused for input for pooling procedures, which generate only one value for every re-\ngion. The pooling layers provide CNN significant translational consistency since a\n8\ntiny change in the input image causes a slight modification in the activation maps.\nApplying convolutions with longer strides is another method for obtaining the pool-\ning’s down sampling effect. The network design is made simpler by eliminating the\npooling levels without compromising performance. Max-pooling is the most widely\nemployed of all these pooling techniques.\n• Fully-Connected Layers: Matrix multiplications have traditionally been the build-\ning blocks of neural networks, which are scattered with sigmoid nonlinearities. The\nlayers of the multiplication matrices are referred to as connected layers due to the\nconnection between each unit in the layer before and each unit in the layer af-\nter. There is just small-scale spatial connectivity when using convolutional layers.\nSignificant amounts of completely linked layers are typically avoided in modern\nnetworks since they require massive parameters.\n• Learning algorithm: Lacking an algorithm to quickly and effectively learn the pa-\nrameters of the model, there is little value for an expensive model. Lacking a tech-\nnique for efficiently acquiring the model’s parameters, a strong, expressive model\nis of little use. In the pre-AlexNet era, greedy layer-wise pre-training techniques\nattempted to create such an efficient approach. A more straightforward supervised\ntraining approach is sufficient to learn a reliable model for tasks relating to com-\nputer vision.\n• Optimization Based on Gradient: - Typically, the backpropagation technique is used\nto train networks, which accelerates mathematical calculation to calculate the gra-\ndient used in the Gradient Descent (GD) algorithm. However, employing GD is\nimpracticable for datasets with many hundreds or even more data points. In these\ncircumstances, Stochastic Gradient Descent (SGD), an approximation where gradi-\nents are computed for data points individually rather than the complete data set, is\nfrequently used. Training using SGD generalizes more successfully than with GD,\nit has been discovered.\n• Batch Normalization:- A helpful regularizes that enhances generalisation and sharply\naccelerates convergence is batch normalisation (BN). The order of presentation of\nthe inputs to each layer varies continuously during the training phase, which is a\nproblem caused by inner covariate variation. This effect typically causes training\n9\nto take longer and requires careful initialization. This problem is addressed by BN,\nwhich normalises a layer’s production stimulation to ensure that its spectrum is\nconstrained to a restricted range. In particular, BN normalises each mini-batch’s\nmean-variance statistics using its running average. Recently, BN has been recog-\nnised as a crucial element of very deep networks.\n• Activation layer :- Deep networks typically have convolutions after each layer,\nwhich then follows a nonlinear process. This is required because convolutions are\nan example of a cascading linear system. Layer-to-layer nonlinearities make the\nmodel more evocative than a model with linear dynamics. Theoretically, as long\nas nonlinearities are ongoing bounded, and gradually rising, no nonlinearity has a\ngreater capacity for expressiveness than any other. The sigmoid or the tanh were\nnonlinearities employed in classical neural networks that feed forward. However,\nthe Rectified Linear Unit (ReLU) is used in contemporary convolutional networks.\nIt has been discovered that CNNs with this nonlinearity train more quickly. The\nleaky- ReLU is a brand-new category of nonlinearity that has lately been intro-\nduced. Leaky-ReLU(x) = max(0, x) + min(0, x) is its formula, where is a preset\nparameter. It is better since it implies that the characteristic can also be taught,\ncreating a model that is considerably deeper. Leaky ReLUs or adjustable ReLUs\nare examples of variations on ReLU(z)=max (0; z). The feature maps, which are\nfrequently also referred to as feature maps, are fed through a process of activation\nto create new tensors.\n1.7.3\n Working on Deep Learning Networks\nSince most deep learning methods rely on neural network topologies, they are referred\ndescribed as \"deep neural networks\".\nNormal neural nets only have a few hidden levels, whereas deeper networks may contain\nup to 150 layers. Very vast quantity of categorised autonomously generated data and neu-\nral network topology extract features.\na) Training from Scratch:- For a deep network to be trained from beginning, a very large\nlabelled data set must be gathered, and a network architecture must be created that will\nallow the network to gain insight into its characteristics and predict. This is advantageous\nfor newly developed apps or applications with numerous output categories. This is a less\n10\nfrequent strategy because these networks often take weeks or even months to train be-\ncause to the volume of data and learning rate.\nb) Transfer Learning:- It is a deep learning technique where a pre-trained model is mod-\nified as part of the transfer learning approach. It begins with a reliable network, like\nAlexNet or GoogleNet, then feeds it new values which are previously undiscovered classes.\nThe task can now be carried, out after making network modifications that are minimal.\nMoreover, processing hundreds of photographs as opposed to millions has the advantage\nof requiring much less data, which cuts down computation time to minutes or hours.\nc) Feature Extraction:- The network can be used as a feature extractor, which is a little less\ntypical and a more specialised method of deep learning. Feature Extraction can remove\nspecific features from the network at any point throughout the training process because\nall the layers are charged with learning specific features from images.\n1.7.4\n Purpose of Deep Learning\nThe models developed using Deep Learning have the potential to provide more precise\nand individualised cancer treatment by better predicting the prognosis of the disease. They\nare superior to or on par with the methods now used in clinical settings. Deep learning\ntechniques are anticipated to help in the proper handling of squamous cell carcinoma of\nthe oral cavity through enhanced diagnostic performance, wise clinical decision-making,\nstreamlining of clinicians’ work, the potential for lowering cancer screening costs, and a\nsuccessful evaluation and detection of the disease. In order to increase the quality of care,\nprofessionals and patients can spend more time talking to one another and deliberating\ntogether. Future research should focus on creating deep learning models that integrate\ndiverse datasets from many modalities.\n• Pre –Processing: Due to a variety of factors, the original image will always contain\nsome noise. The accuracy of the diagnosis is compromised by these noises. A cru-\ncial part of the image processing process is pre-processing. Asymmetric filtration is\na filter that is frequently used to enhance grayscale photographs by reducing noise\nand improving image arrangement, particularly edge boundaries.\n• Feature Extraction: - we can generate new features from the previous feature and\nthen we can delete the original features by doing this we can reduce the features\n11\npresent in the dataset. It helps us to categorize the images into different groups.\n• Feature Selection: - Providing a vast amount of features to the model can result\nin a overfitted model with a very high computational time, having a better feature\nextraction will help in reducing the time complexity\nFigure 1.4: Flow chart showing different Phases in detection of oral cancer\n1.8\n Metaheuristic Optimization\nReal-world optimisation issues frequently involve a large number of choice variables, in-\ntricate nonlinear constraints, and difficult objective functions, which makes them more\nand more difficult to solve. Using conventional strategies like numerical methods, the\n12\nglobal optimization is less effective, particularly when limitations or objective functions\ninclude many peaks. Strong instruments for tackling difficult optimisation problems,\nmetaheuristic algorithms are gaining popularity.\nThe simplicity of metaheuristic algorithms is by far their most notable feature. The fun-\ndamental theories or mathematical models underlying these metaheuristic techniques are\nderived from nature. The majority of these techniques are straightforward and simple to\nuse. One can utilise metaheuristics to solve real-world problems thanks to their usability.\nAdditionally, it is simple to create their versions using current techniques.\nThese optimisation technologies can be thought of as \"black boxes,\" capable of providing\na set of outputs for a specific problem for a specific set of inputs. One of the most crucial\naspects of metaheuristic algorithms is randomization. This makes it possible for meta-\nheuristic algorithms to effectively avoid trapping in local optima and to search the whole\nsearch space. More specifically, it enables numerous metaheuristics to handle issues in-\nvolving an ambiguous search space or various local optima. Finally, because of their ex-\ntreme adaptability and flexibility, these metaheuristics can be used to solve a wide range\nof optimisation issues, including non-linear issues, issues involving non-differentiable\nvariables, and issues involving sophisticated numerical calculations and a large number\nof local minima.\n1.9\n Motivation\nThe latest trend in increase of oral cancer is having an adverse effect on health of human\nbeing. Oral cancer can be treated if detected early, with the increase in total number of\ncases of oral cancer we need an accurate and fast way to detect cancer cells. The risk\nof oral cancer is in all age groups but elder people are more prone to it due to unhealthy\nlifestyle. A lot of people have experienced financial troubles. It is crucial for the early\ndiagnosis of disease so that patients can start taking preventative measures right away. AI,\nwhich consists of machine learning and deep learning, is heavily reliant on classification,\ngrading, segmentation, and computer vision. To more or less better model optimisation is\nthe main reason for conducting research in this field.\n• Deep learning concept fascinate me to learn more in this area. Deep learning based\nmodel can detect oral cancer with early signs that can be captured by modern cam-\n13\neras\n• Clinical Images can give an more accurate and fast result as compare to normal\nmethods applied by Doctors\n1.10\n Problem Statement and Research Objective\nA large number of deaths were recorded from oral cancer as a result of lack of its identifi-\ncation and late treatment. Oral cavity cancer has a significant mortality rate that is rising.\nIt is crucial to develop and put into practise a method for detecting this malignancy early\non. By identifying cancer early and adopting preventative measures, it is simple to limit\nthe number of deaths brought on by the disease. Although many researchers have already\nconducted their research in the field of oral cancer disorders, there is still a great deal of\nresearch that may be done in this area owing to performance improvements.\nMachine learning has advanced to the point where getting more use out of it is all but\nimpossible during the last several years. The performance of Deep learning models have\nincreased but there is still a concern of model size, low accuracy and high computation\ntime.\n• To propose and implement optimized Deep learning algorithm for detection of oral\ncancer in it’s early stages.\n• To implement Metaheuristic optimization for better weight selection of clinical im-\nages.\n• To conduct an analysis and compare the proposed approach with state of art models\non basic of evaluation matrices like accuracy, precision, Sensitivity and Specificity.\n1.11\n Thesis outline\nThe chapters of the thesis are organised consistently into an overview, key facts and fig-\nures, significant content, pertinent data, and a final chapter summary. All references are\nincluded at the end and each Figure, table, and piece of text is correctly referenced. The\nfive chapters that make up this thesis are arranged as follows:\n14\n• Chapter 1: It provides a succinct overview of oral cancer, including its kinds, symp-\ntoms, and methods of diagnosis. It describes how the process of making medical\ndiagnoses has been transformed by machine learning, neural networks, and deep\nneural networks. Why has CNN surpassed conventional neural networks? what\nmotivated and inspired you to work in medicine. Additionally, it provides informa-\ntion about the goals and motivation.\n• Chapter 2: It gives a brief overview of the literature for a number of researchers who\nworked on various methods for automatic oral cancer diagnosis, image processing,\nand texture-based categorization. Artificial neural networks, deep learning. A re-\nview of all pertinent theories and techniques for diagnosing oral cancer that are\navailable in the literature.\n• Chapter 3: The chapter sheds insight on a crucial experiment study and the approach\nused to carry out our investigation. The models and various detection architectures\nemployed by CNN have been described. The proposed model is covered in this\nchapter; it has fewer parameters and a shallower learning curve than the pretrained\nmodel, but it is more accurate.\n• Chapter 4: With the use of a graph, bar chart, and other presentation approaches,\nall model and performance metric results are shown. The model’s shortcomings are\nthen displayed and contrasted with the suggested model.\n• Chapter 5: The entire work is concluded in the last chapter. This chapter also\ndiscusses how we might enhance our efforts in the future.","recorded":"2024-10-24 13:23:17.540417744","filePath":"null","pinned":false},{"value":"Cancer is a disease brought on by aberrant cells when an internal component is expanding\nout of control. A portion of the body’s cells in all tumors, begin to divide rapidly and\nspread to parts of the neighboring tissues. Among the millions of cells, cancer can appear\nvirtually at any place in the body. Normally, human cells multiply and divide to produce\nnew cells as the body requires them. When a cell becomes damaged or old, it expires and\nis replaced by a fresh cell. But as cancer grows, this systematic mechanism disintegrates.\nOld or injured cells that should have died survive, as cells become more and more erro-\nneous whereas new cells are generated even when they are unwanted. These cells can\ndivide to form new ones, which may lead to tumor-like growth. Solid tumors, or masses\nof tissue, are a common kind of cancer. Leukemias and other blood cancers typically do\nnot develop solid tumors\n1.1\n Oral Cancer\nThe mouth’s cells are the first to develop oral cancer. A cancerous (malignant) nodule is\na group of cancer cells tumor that has the ability to invade neighboring tissue and wreck\nmisery on it. It can also metastasize to different parts of the body. Nodes of lymph in\nthe neck are the part where mouth cancer spreads most frequently. Oral cancer may also\nbe referred to as mouth cancer. Sometimes, cells that are present in the mouth undergo\nchanges and will stop growing or behaving properly. These alterations could result in\nbenign (non-cancerous) tumors like warts and fibromas. Precancerous diseases can also\nbe brought on by changes in the mouth’s cells. This indicates that although the abnormal\ncells are not now cancer, there is a potential that they could develop into cancer if lefuntreated. Leukoplakia and erythroplakia are two of the most prevalent precancerous\ndisorders of the mouth.\nOral cancer can, however, occasionally result from alterations to the mouth’s cellular\nstructure. The oral mucosa (mucous membrane) is a lining that lines the mouth. The\nsquamous epithelium, which composes the oral mucosa, is made up of squamous cells.\nThese thin, flat squamous cells are where mouth cancer typically begins. The term for\nthis type of cancer is mouth squamous cell carcinoma.\n1.1.1\n Type of Oral Cancer\nThe following organs can develop cancer:\n• Lips\n• Tongue\n• Inner lining of the cheek\n• Gums\n• Mouth Cancer\n• Hard and Soft Palate\n1.2\n Mouth Cancer\nMouth cancer, commonly referred to as oral cancer, happens whenever a tumor forms\ninside the mouth lining. It could be located on the surface of the tongue, the interior of\nthe cheeks, the palate, the lips themselves, or the gums. Additionally, the glands that\ncreate tumors saliva, the tonsils in the rear within the mouth. But these occur frequently.\nSymptoms of mouth cancer:\n• A mouth or lip sore that does not heal\n• An internal mouth patch that is either white or red\n• A growth or bulge inside your mouth; loose teeth;\n• Painful or difficult swallowing\n2\n1.2.1\n Cause of Mouth Cancer\nWhen DNA alterations (mutations) occur in the mouth or lip cells, mouth carcinomas de-\nvelop. DNA includes the instructions for what the cell must accomplish. When normally\nfunctioning cells would die, alterations cause the continued growth and division of the\ncells. The aberrant mouth cancer cells can assemble into a tumor. In time, they might\nspread from the inside of the mouth to the whole body, including the neck or various parts\nof the head.\nMouth cancers tend to start in the flat, thin cells (squamous cells) which define the sur-\nface of the lips and the interior of the mouth. Oral cancer is most frequently caused by\nsquamous cell tumors.\n1.3\n Human Mouth Structure\nThe start of the human mouth is where the lips and skin converge Figure 1.1 shows the\nstructure of the human mouth. The roof of the mouth is made up of both hard and soft\npalates. A soft palate divides the mouth from the nasopharynx (the upper part of the\npharynx), which is connected to the mouth via the oropharynx (the middle section of the\npharynx). The sides of the mouth are formed by the cheeks’ inner surface (De Angeli et\nal. 2022). The majority of the mouth’s floor, or lowest portion, is occupied by the tongue.\nThe mouth can be divided into various sections, including-:\n• The Lips\n• The Tonsils and The Soft Palate\n• The Uvula and the Tongue\n• The buccal mucosa, which coats the cheekbones’ interior\n• The roof of the mouth\n• Teeth, gums, and alveolar ridge, which is the ridge-like border of the jaws that\ncontains the tooth sockets.\n• The Mandible (Lower Jawbone)\n3\nFigure 1.1: Structure of Human mouth\n(German and Palmer 2006)\n1.4\n Diagnosing Techniques for Oral Cancer\nThere are different techniques that are used for the diagnosis of oral cancer, few of the\nclinical techniques used by doctors are discussed below :-\nBarium Swallow: - The voice box, the throat, referral, and surroundings may display\nabnormalities during a barium swallow test, which is also frequently used to find small,\nearly oral tumors.\nBiopsy: - The initial step in identifying mouth cancer is an oral tissue biopsy. A little bit\nof aberrant tissue from the area where oral cancer is suspected is removed by the surgeon\nduring the biopsy. An oral cancer diagnosis may be confirmed by biopsy. The following\ntypes of biopsies are frequently used to identify oral carcinoma:\n• Incisive biopsies: The region has a small amount of tissue taken from it that appears\nto be abnormal. If the abnormal location is easily accessible, the specimen could\nbe obtained at the office of a doctor. If the cancer is more deeply embedded in the\nmouth or throat, biopsy procedures might have to be carried out in a surgical theatre\nwhile receiving anesthesia in order to lessen pain.\n• Exfoliative cytology: Cell samples are gently scraped from a questionable loca-\ntion. To make the cells visible under a microscope, they are put upon a transparent\n4\nslide, and subsequently colored. A deeper biopsy will be done if any cells seem\nsuspicious.\nImage-based tests\n• Computerized Tomography, or CT, Scanning – Information on the size, shape, and\nlocation of any tumors can be obtained via a CT scan, which can help detect lymph\nnodes that are bulging that may contain cancer cells.\n• Magnetic Resonance Imaging (MRI): Oral cancer may be examined with an MRI\nscan, although this is less usual. MRIs give a very thorough picture and may be\nvery helpful in figuring out whether other areas of the body, such as the neck, have\nbeen affected by the disease’s spread.\n• Positron emission computed tomography (PET): Patients with cancer of the oral\ncavity might get a scan using PET technology to find out whether the disease has\nmigrated to the lymph nodes or whether it has only recently progressed to that\nlocation.\n• Genomic testing for advanced oral cancer: -Genomic testing is sometimes known as\nmolecular profiling or cancer sequencing. Examining the collected cells is required\n8 from a biopsy in order to check for any genetic mutations (changes in your DNA)\nthat might be connected to the person’s particular type of cancer.\n1.5\n Oral cancer: Globally\nAmong the most prevalent malignancies worldwide is oral cancer. The majority of cases\nof this subtype of head and neck cancer begin in the cells of squamous tissue that cover\nthe surface of our mouth, tongue, and faces. When this fails to be identified and if not\naddressed in a timely manner, it could be deadly. About 53,000 incidences of oral cancer,\nor three percent of all cancers identified during the study in US annually, are related to\noral cancer. Oral cancer strikes males more frequently than females, more than twice as\noften, and persons over an age of 40 are most at risk.\nSmoking, drinking alcoholic beverages, or having HPV, short for People Papilloma virus\ninfection are the main causes of oral cancer. In 2020, there are expected to be over 177,000\n5\ndeaths globally from lip and oral cavity cancer, In spite of improvements mouth cancer\nfatality rates have remained high in recent decades.\nThe majority of mouth cancer patients, particularly those located in countryside regions,\ncan’t obtain fast, effective diagnosis and treatment, which lowers their chance of survival.\nDepending on race and location, patients with cancer have a five-year living rate among\nthe 50%. According to reports, the survival rate in developed nations can reach 65%.\nIn contrast, leaning upon the area of the mouth cancer affected, a living rate of fifteen\npercent is noted in some countryside areas. It’s because cancer therapy may be highly\nexpensive, especially in later stages. Health experts and the general public both lack a\nsignificant grasp of oral cancer. The 2020 Cancer Statistics Report for India states 66.6\npercent of patients with head and neck cancer had already progressed locally when they\nreceived their diagnosis. Inflammation or ulcers that do not heal, along with discomfort\nand bleeding, are signs of oral cancer.\nOral cancer can be caused by a number of habits, with smoking and drinking being the\ntwo most significant ones. Consuming maggots is so common in India that it causes in-\nternal gum damage.\nGLOBOCAN (Global Cancer Incidence, Mortality and Prevalence) anticipated that in\nFigure 1.2: Global age standardized prevalence of tobacco smoking source World Health\nOrganization\n(Dai, Gakidou, and Lopez 2022)\n2018, there would be 177,384 cancer-related deaths and 354,864 new instances of cancer,\n6\nwhich corresponds to two percent and one point nine percent of all occurrences and fa-\ntalities from cancer, respectively. In summary, mouth cancer, which accounts for around\none-third of all cancer cases, is a major reason for death in Bangladesh, Pakistan, Taiwan,\nand India.\n1.6\n Issues with Oral Cancer Manual Diagnoses\nThe primary problem with manual cancer diagnosis is the delay in diagnosis. It requires\nextremely competent labor, and the number of needed diagnostic tests is increasing dra-\nmatically. Because of the time requirements for a proper diagnosis, it is less likely that\nan early identification of the tumor grade will be made.Pathologists heavy workload is a\nserious worry, and this also affects how well they can anticipate outcomes. It also Prevent\nthe delivery of an accurate diagnosis report as the findings must be carefully crafted to\navoid any fatalities.","recorded":"2024-10-24 13:23:05.035134500","filePath":"null","pinned":false},{"value":"Cancer is a disease brought on by aberrant cells when an internal component is expanding\nout of control. A portion of the body’s cells in all tumors, begin to divide rapidly and\nspread to parts of the neighboring tissues. Among the millions of cells, cancer can appear\nvirtually at any place in the body. Normally, human cells multiply and divide to produce\nnew cells as the body requires them. When a cell becomes damaged or old, it expires and\nis replaced by a fresh cell. But as cancer grows, this systematic mechanism disintegrates.\nOld or injured cells that should have died survive, as cells become more and more erro-\nneous whereas new cells are generated even when they are unwanted. These cells can\ndivide to form new ones, which may lead to tumor-like growth. Solid tumors, or masses\nof tissue, are a common kind of cancer. Leukemias and other blood cancers typically do\nnot develop solid tumors\n1.1\n Oral Cancer\nThe mouth’s cells are the first to develop oral cancer. A cancerous (malignant) nodule is\na group of cancer cells tumor that has the ability to invade neighboring tissue and wreck\nmisery on it. It can also metastasize to different parts of the body. Nodes of lymph in\nthe neck are the part where mouth cancer spreads most frequently. Oral cancer may also\nbe referred to as mouth cancer. Sometimes, cells that are present in the mouth undergo\nchanges and will stop growing or behaving properly. These alterations could result in\nbenign (non-cancerous) tumors like warts and fibromas. Precancerous diseases can also\nbe brought on by changes in the mouth’s cells. This indicates that although the abnormal\ncells are not now cancer, there is a potential that they could develop into cancer if lefuntreated. Leukoplakia and erythroplakia are two of the most prevalent precancerous\ndisorders of the mouth.\nOral cancer can, however, occasionally result from alterations to the mouth’s cellular\nstructure. The oral mucosa (mucous membrane) is a lining that lines the mouth. The\nsquamous epithelium, which composes the oral mucosa, is made up of squamous cells.\nThese thin, flat squamous cells are where mouth cancer typically begins. The term for\nthis type of cancer is mouth squamous cell carcinoma.\n1.1.1\n Type of Oral Cancer\nThe following organs can develop cancer:\n• Lips\n• Tongue\n• Inner lining of the cheek\n• Gums\n• Mouth Cancer\n• Hard and Soft Palate\n1.2\n Mouth Cancer\nMouth cancer, commonly referred to as oral cancer, happens whenever a tumor forms\ninside the mouth lining. It could be located on the surface of the tongue, the interior of\nthe cheeks, the palate, the lips themselves, or the gums. Additionally, the glands that\ncreate tumors saliva, the tonsils in the rear within the mouth. But these occur frequently.\nSymptoms of mouth cancer:\n• A mouth or lip sore that does not heal\n• An internal mouth patch that is either white or red\n• A growth or bulge inside your mouth; loose teeth;\n• Painful or difficult swallowing\n2\n1.2.1\n Cause of Mouth Cancer\nWhen DNA alterations (mutations) occur in the mouth or lip cells, mouth carcinomas de-\nvelop. DNA includes the instructions for what the cell must accomplish. When normally\nfunctioning cells would die, alterations cause the continued growth and division of the\ncells. The aberrant mouth cancer cells can assemble into a tumor. In time, they might\nspread from the inside of the mouth to the whole body, including the neck or various parts\nof the head.\nMouth cancers tend to start in the flat, thin cells (squamous cells) which define the sur-\nface of the lips and the interior of the mouth. Oral cancer is most frequently caused by\nsquamous cell tumors.\n1.3\n Human Mouth Structure\nThe start of the human mouth is where the lips and skin converge Figure 1.1 shows the\nstructure of the human mouth. The roof of the mouth is made up of both hard and soft\npalates. A soft palate divides the mouth from the nasopharynx (the upper part of the\npharynx), which is connected to the mouth via the oropharynx (the middle section of the\npharynx). The sides of the mouth are formed by the cheeks’ inner surface (De Angeli et\nal. 2022). The majority of the mouth’s floor, or lowest portion, is occupied by the tongue.\nThe mouth can be divided into various sections, including-:\n• The Lips\n• The Tonsils and The Soft Palate\n• The Uvula and the Tongue\n• The buccal mucosa, which coats the cheekbones’ interior\n• The roof of the mouth\n• Teeth, gums, and alveolar ridge, which is the ridge-like border of the jaws that\ncontains the tooth sockets.\n• The Mandible (Lower Jawbone)\n3\nFigure 1.1: Structure of Human mouth\n(German and Palmer 2006)\n1.4\n Diagnosing Techniques for Oral Cancer\nThere are different techniques that are used for the diagnosis of oral cancer, few of the\nclinical techniques used by doctors are discussed below :-\nBarium Swallow: - The voice box, the throat, referral, and surroundings may display\nabnormalities during a barium swallow test, which is also frequently used to find small,\nearly oral tumors.\nBiopsy: - The initial step in identifying mouth cancer is an oral tissue biopsy. A little bit\nof aberrant tissue from the area where oral cancer is suspected is removed by the surgeon\nduring the biopsy. An oral cancer diagnosis may be confirmed by biopsy. The following\ntypes of biopsies are frequently used to identify oral carcinoma:\n• Incisive biopsies: The region has a small amount of tissue taken from it that appears\nto be abnormal. If the abnormal location is easily accessible, the specimen could\nbe obtained at the office of a doctor. If the cancer is more deeply embedded in the\nmouth or throat, biopsy procedures might have to be carried out in a surgical theatre\nwhile receiving anesthesia in order to lessen pain.\n• Exfoliative cytology: Cell samples are gently scraped from a questionable loca-\ntion. To make the cells visible under a microscope, they are put upon a transparent\n4\nslide, and subsequently colored. A deeper biopsy will be done if any cells seem\nsuspicious.\nImage-based tests\n• Computerized Tomography, or CT, Scanning – Information on the size, shape, and\nlocation of any tumors can be obtained via a CT scan, which can help detect lymph\nnodes that are bulging that may contain cancer cells.\n• Magnetic Resonance Imaging (MRI): Oral cancer may be examined with an MRI\nscan, although this is less usual. MRIs give a very thorough picture and may be\nvery helpful in figuring out whether other areas of the body, such as the neck, have\nbeen affected by the disease’s spread.\n• Positron emission computed tomography (PET): Patients with cancer of the oral\ncavity might get a scan using PET technology to find out whether the disease has\nmigrated to the lymph nodes or whether it has only recently progressed to that\nlocation.\n• Genomic testing for advanced oral cancer: -Genomic testing is sometimes known as\nmolecular profiling or cancer sequencing. Examining the collected cells is required\n8 from a biopsy in order to check for any genetic mutations (changes in your DNA)\nthat might be connected to the person’s particular type of cancer.\n1.5\n Oral cancer: Globally\nAmong the most prevalent malignancies worldwide is oral cancer. The majority of cases\nof this subtype of head and neck cancer begin in the cells of squamous tissue that cover\nthe surface of our mouth, tongue, and faces. When this fails to be identified and if not\naddressed in a timely manner, it could be deadly. About 53,000 incidences of oral cancer,\nor three percent of all cancers identified during the study in US annually, are related to\noral cancer. Oral cancer strikes males more frequently than females, more than twice as\noften, and persons over an age of 40 are most at risk.\nSmoking, drinking alcoholic beverages, or having HPV, short for People Papilloma virus\ninfection are the main causes of oral cancer. In 2020, there are expected to be over 177,000\n5\ndeaths globally from lip and oral cavity cancer, In spite of improvements mouth cancer\nfatality rates have remained high in recent decades.\nThe majority of mouth cancer patients, particularly those located in countryside regions,\ncan’t obtain fast, effective diagnosis and treatment, which lowers their chance of survival.\nDepending on race and location, patients with cancer have a five-year living rate among\nthe 50%. According to reports, the survival rate in developed nations can reach 65%.\nIn contrast, leaning upon the area of the mouth cancer affected, a living rate of fifteen\npercent is noted in some countryside areas. It’s because cancer therapy may be highly\nexpensive, especially in later stages. Health experts and the general public both lack a\nsignificant grasp of oral cancer. The 2020 Cancer Statistics Report for India states 66.6\npercent of patients with head and neck cancer had already progressed locally when they\nreceived their diagnosis. Inflammation or ulcers that do not heal, along with discomfort\nand bleeding, are signs of oral cancer.\nOral cancer can be caused by a number of habits, with smoking and drinking being the\ntwo most significant ones. Consuming maggots is so common in India that it causes in-\nternal gum damage.\nGLOBOCAN (Global Cancer Incidence, Mortality and Prevalence) anticipated that in\nFigure 1.2: Global age standardized prevalence of tobacco smoking source World Health\nOrganization\n(Dai, Gakidou, and Lopez 2022)\n2018, there would be 177,384 cancer-related deaths and 354,864 new instances of cancer,\n6\nwhich corresponds to two percent and one point nine percent of all occurrences and fa-\ntalities from cancer, respectively. In summary, mouth cancer, which accounts for around\none-third of all cancer cases, is a major reason for death in Bangladesh, Pakistan, Taiwan,\nand India.\n1.6\n Issues with Oral Cancer Manual Diagnoses\nThe primary problem with manual cancer diagnosis is the delay in diagnosis. It requires\nextremely competent labor, and the number of needed diagnostic tests is increasing dra-\nmatically. Because of the time requirements for a proper diagnosis, it is less likely that\nan early identification of the tumor grade will be made.Pathologists heavy workload is a\nserious worry, and this also affects how well they can anticipate outcomes. It also Prevent\nthe delivery of an accurate diagnosis report as the findings must be carefully crafted to\navoid any fatalities.\n1.7\n Deep Learning\nOne of the main components of an Artificially Intelligent system is learning. Learning\nmeans when a computer program can learn through its surrounding. Artificially intelli-\ngent systems have the ability to mimic the human brain and have the ability to process\ninformation and develop various patterns used to make decisions (Dubuc et al. 2022). A\nsub type of machine learning called \"deep learning\" in artificial intelligence (AI) allows\nnetworks to learn unsupervised from unlabelled input. Deep learning can also refer to\ndeep neural networks or deep learning.\n1.7.1\n Importance of Deep Learning\nMachine learning techniques can now build and learn from a large pool of training data\nbecause to improvements in computer speed and memory over time.\nDeep learning has been a cutting-edge method for humanity, especially when the Informa-\ntion is noisy. Artificial neural networks can learn any function with just one hidden layer,\nregardless of how ambiguous it is, which is why they are regarded as universal function\napproximations.\n7\n1.7.2\n CNN\nConvolutional neural network (CNN) is a subtype of ANN. In at least one of their layers,\nCNN’s replace conventional matrix multiplication methods with the convolution mathe-\nmatical technique. Since they were developed specifically to handle pixel data, they are\nused in image recognition and processing. The design with which CNN is built is compa-\nrable with the model of neural connection like a person’s brain (Jeyaraj, B. K. Panigrahi,\nand Samuel Nadar 2022). Because of the way CNN is built, there are some strong prefer-\nences ingrained in them, which makes it easier to comprehend why they are so effective.\nCNN can be seen as a feed-forward network but having connection with each image can\nFigure 1.3: A CNN Architecture\n(Sun et al. 2019)\nbe inefficient. Therefore, we can prune the useless connection between the hidden layers\nto increase the performance of the layer. A CNN is a special artificial neural network with\nlimited connections between the layers of artificial neural network.\n• Max-Pooling: Each feature map produced by processing the input through many\nlayers of convolution is subsequently combined in a pooling layer. Little grids are\nused for input for pooling procedures, which generate only one value for every re-\ngion. The pooling layers provide CNN significant translational consistency since a\n8\ntiny change in the input image causes a slight modification in the activation maps.\nApplying convolutions with longer strides is another method for obtaining the pool-\ning’s down sampling effect. The network design is made simpler by eliminating the\npooling levels without compromising performance. Max-pooling is the most widely\nemployed of all these pooling techniques.\n• Fully-Connected Layers: Matrix multiplications have traditionally been the build-\ning blocks of neural networks, which are scattered with sigmoid nonlinearities. The\nlayers of the multiplication matrices are referred to as connected layers due to the\nconnection between each unit in the layer before and each unit in the layer af-\nter. There is just small-scale spatial connectivity when using convolutional layers.\nSignificant amounts of completely linked layers are typically avoided in modern\nnetworks since they require massive parameters.\n• Learning algorithm: Lacking an algorithm to quickly and effectively learn the pa-\nrameters of the model, there is little value for an expensive model. Lacking a tech-\nnique for efficiently acquiring the model’s parameters, a strong, expressive model\nis of little use. In the pre-AlexNet era, greedy layer-wise pre-training techniques\nattempted to create such an efficient approach. A more straightforward supervised\ntraining approach is sufficient to learn a reliable model for tasks relating to com-\nputer vision.\n• Optimization Based on Gradient: - Typically, the backpropagation technique is used\nto train networks, which accelerates mathematical calculation to calculate the gra-\ndient used in the Gradient Descent (GD) algorithm. However, employing GD is\nimpracticable for datasets with many hundreds or even more data points. In these\ncircumstances, Stochastic Gradient Descent (SGD), an approximation where gradi-\nents are computed for data points individually rather than the complete data set, is\nfrequently used. Training using SGD generalizes more successfully than with GD,\nit has been discovered.\n• Batch Normalization:- A helpful regularizes that enhances generalisation and sharply\naccelerates convergence is batch normalisation (BN). The order of presentation of\nthe inputs to each layer varies continuously during the training phase, which is a\nproblem caused by inner covariate variation. This effect typically causes training\n9\nto take longer and requires careful initialization. This problem is addressed by BN,\nwhich normalises a layer’s production stimulation to ensure that its spectrum is\nconstrained to a restricted range. In particular, BN normalises each mini-batch’s\nmean-variance statistics using its running average. Recently, BN has been recog-\nnised as a crucial element of very deep networks.\n• Activation layer :- Deep networks typically have convolutions after each layer,\nwhich then follows a nonlinear process. This is required because convolutions are\nan example of a cascading linear system. Layer-to-layer nonlinearities make the\nmodel more evocative than a model with linear dynamics. Theoretically, as long\nas nonlinearities are ongoing bounded, and gradually rising, no nonlinearity has a\ngreater capacity for expressiveness than any other. The sigmoid or the tanh were\nnonlinearities employed in classical neural networks that feed forward. However,\nthe Rectified Linear Unit (ReLU) is used in contemporary convolutional networks.\nIt has been discovered that CNNs with this nonlinearity train more quickly. The\nleaky- ReLU is a brand-new category of nonlinearity that has lately been intro-\nduced. Leaky-ReLU(x) = max(0, x) + min(0, x) is its formula, where is a preset\nparameter. It is better since it implies that the characteristic can also be taught,\ncreating a model that is considerably deeper. Leaky ReLUs or adjustable ReLUs\nare examples of variations on ReLU(z)=max (0; z). The feature maps, which are\nfrequently also referred to as feature maps, are fed through a process of activation\nto create new tensors.\n1.7.3\n Working on Deep Learning Networks\nSince most deep learning methods rely on neural network topologies, they are referred\ndescribed as \"deep neural networks\".\nNormal neural nets only have a few hidden levels, whereas deeper networks may contain\nup to 150 layers. Very vast quantity of categorised autonomously generated data and neu-\nral network topology extract features.\na) Training from Scratch:- For a deep network to be trained from beginning, a very large\nlabelled data set must be gathered, and a network architecture must be created that will\nallow the network to gain insight into its characteristics and predict. This is advantageous\nfor newly developed apps or applications with numerous output categories. This is a less\n10\nfrequent strategy because these networks often take weeks or even months to train be-\ncause to the volume of data and learning rate.\nb) Transfer Learning:- It is a deep learning technique where a pre-trained model is mod-\nified as part of the transfer learning approach. It begins with a reliable network, like\nAlexNet or GoogleNet, then feeds it new values which are previously undiscovered classes.\nThe task can now be carried, out after making network modifications that are minimal.\nMoreover, processing hundreds of photographs as opposed to millions has the advantage\nof requiring much less data, which cuts down computation time to minutes or hours.\nc) Feature Extraction:- The network can be used as a feature extractor, which is a little less\ntypical and a more specialised method of deep learning. Feature Extraction can remove\nspecific features from the network at any point throughout the training process because\nall the layers are charged with learning specific features from images.\n1.7.4\n Purpose of Deep Learning\nThe models developed using Deep Learning have the potential to provide more precise\nand individualised cancer treatment by better predicting the prognosis of the disease. They\nare superior to or on par with the methods now used in clinical settings. Deep learning\ntechniques are anticipated to help in the proper handling of squamous cell carcinoma of\nthe oral cavity through enhanced diagnostic performance, wise clinical decision-making,\nstreamlining of clinicians’ work, the potential for lowering cancer screening costs, and a\nsuccessful evaluation and detection of the disease. In order to increase the quality of care,\nprofessionals and patients can spend more time talking to one another and deliberating\ntogether. Future research should focus on creating deep learning models that integrate\ndiverse datasets from many modalities.\n• Pre –Processing: Due to a variety of factors, the original image will always contain\nsome noise. The accuracy of the diagnosis is compromised by these noises. A cru-\ncial part of the image processing process is pre-processing. Asymmetric filtration is\na filter that is frequently used to enhance grayscale photographs by reducing noise\nand improving image arrangement, particularly edge boundaries.\n• Feature Extraction: - we can generate new features from the previous feature and\nthen we can delete the original features by doing this we can reduce the features\n11\npresent in the dataset. It helps us to categorize the images into different groups.\n• Feature Selection: - Providing a vast amount of features to the model can result\nin a overfitted model with a very high computational time, having a better feature\nextraction will help in reducing the time complexity\nFigure 1.4: Flow chart showing different Phases in detection of oral cancer\n1.8\n Metaheuristic Optimization\nReal-world optimisation issues frequently involve a large number of choice variables, in-\ntricate nonlinear constraints, and difficult objective functions, which makes them more\nand more difficult to solve. Using conventional strategies like numerical methods, the\n12\nglobal optimization is less effective, particularly when limitations or objective functions\ninclude many peaks. Strong instruments for tackling difficult optimisation problems,\nmetaheuristic algorithms are gaining popularity.\nThe simplicity of metaheuristic algorithms is by far their most notable feature. The fun-\ndamental theories or mathematical models underlying these metaheuristic techniques are\nderived from nature. The majority of these techniques are straightforward and simple to\nuse. One can utilise metaheuristics to solve real-world problems thanks to their usability.\nAdditionally, it is simple to create their versions using current techniques.\nThese optimisation technologies can be thought of as \"black boxes,\" capable of providing\na set of outputs for a specific problem for a specific set of inputs. One of the most crucial\naspects of metaheuristic algorithms is randomization. This makes it possible for meta-\nheuristic algorithms to effectively avoid trapping in local optima and to search the whole\nsearch space. More specifically, it enables numerous metaheuristics to handle issues in-\nvolving an ambiguous search space or various local optima. Finally, because of their ex-\ntreme adaptability and flexibility, these metaheuristics can be used to solve a wide range\nof optimisation issues, including non-linear issues, issues involving non-differentiable\nvariables, and issues involving sophisticated numerical calculations and a large number\nof local minima.\n1.9\n Motivation\nThe latest trend in increase of oral cancer is having an adverse effect on health of human\nbeing. Oral cancer can be treated if detected early, with the increase in total number of\ncases of oral cancer we need an accurate and fast way to detect cancer cells. The risk\nof oral cancer is in all age groups but elder people are more prone to it due to unhealthy\nlifestyle. A lot of people have experienced financial troubles. It is crucial for the early\ndiagnosis of disease so that patients can start taking preventative measures right away. AI,\nwhich consists of machine learning and deep learning, is heavily reliant on classification,\ngrading, segmentation, and computer vision. To more or less better model optimisation is\nthe main reason for conducting research in this field.\n• Deep learning concept fascinate me to learn more in this area. Deep learning based\nmodel can detect oral cancer with early signs that can be captured by modern cam-\n13\neras\n• Clinical Images can give an more accurate and fast result as compare to normal\nmethods applied by Doctors\n1.10\n Problem Statement and Research Objective\nA large number of deaths were recorded from oral cancer as a result of lack of its identifi-\ncation and late treatment. Oral cavity cancer has a significant mortality rate that is rising.\nIt is crucial to develop and put into practise a method for detecting this malignancy early\non. By identifying cancer early and adopting preventative measures, it is simple to limit\nthe number of deaths brought on by the disease. Although many researchers have already\nconducted their research in the field of oral cancer disorders, there is still a great deal of\nresearch that may be done in this area owing to performance improvements.\nMachine learning has advanced to the point where getting more use out of it is all but\nimpossible during the last several years. The performance of Deep learning models have\nincreased but there is still a concern of model size, low accuracy and high computation\ntime.\n• To propose and implement optimized Deep learning algorithm for detection of oral\ncancer in it’s early stages.\n• To implement Metaheuristic optimization for better weight selection of clinical im-\nages.\n• To conduct an analysis and compare the proposed approach with state of art models\non basic of evaluation matrices like accuracy, precision, Sensitivity and Specificity.\n1.11\n Thesis outline\nThe chapters of the thesis are organised consistently into an overview, key facts and fig-\nures, significant content, pertinent data, and a final chapter summary. All references are\nincluded at the end and each Figure, table, and piece of text is correctly referenced. The\nfive chapters that make up this thesis are arranged as follows:\n14\n• Chapter 1: It provides a succinct overview of oral cancer, including its kinds, symp-\ntoms, and methods of diagnosis. It describes how the process of making medical\ndiagnoses has been transformed by machine learning, neural networks, and deep\nneural networks. Why has CNN surpassed conventional neural networks? what\nmotivated and inspired you to work in medicine. Additionally, it provides informa-\ntion about the goals and motivation.\n• Chapter 2: It gives a brief overview of the literature for a number of researchers who\nworked on various methods for automatic oral cancer diagnosis, image processing,\nand texture-based categorization. Artificial neural networks, deep learning. A re-\nview of all pertinent theories and techniques for diagnosing oral cancer that are\navailable in the literature.\n• Chapter 3: The chapter sheds insight on a crucial experiment study and the approach\nused to carry out our investigation. The models and various detection architectures\nemployed by CNN have been described. The proposed model is covered in this\nchapter; it has fewer parameters and a shallower learning curve than the pretrained\nmodel, but it is more accurate.\n• Chapter 4: With the use of a graph, bar chart, and other presentation approaches,\nall model and performance metric results are shown. The model’s shortcomings are\nthen displayed and contrasted with the suggested model.\n• Chapter 5: The entire work is concluded in the last chapter. This chapter also\ndiscusses how we might enhance our efforts in the future.","recorded":"2024-10-24 13:19:00.175188261","filePath":"null","pinned":false},{"value":"chat.tinygrad.org","recorded":"2024-10-24 11:39:19.851389071","filePath":"null","pinned":false},{"value":"\"idle_inhibitor\": {\n        \"format\": \"{icon}\",\n        \"format-icons\": {\n            \"activated\": \"\",\n            \"deactivated\": \"\"\n        }\n    },","recorded":"2024-10-23 22:21:53.227543478","filePath":"null","pinned":false},{"value":"# Load the model\nsaved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_model.h5\"\nmodel = tf.keras.models.load_model(saved_model_path)\n\n# Since training history is saved to CSV, load it from there\nimport pandas as pd\ntraining_history = pd.read_csv(log_path)\n\n# Get generator and discriminator losses\ngenerator_loss = training_history['Generator Loss'].tolist()\ndiscriminator_loss = training_history['Discriminator Loss'].tolist()","recorded":"2024-10-23 15:18:08.864613066","filePath":"null","pinned":false},{"value":"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models, optimizers\nimport matplotlib.pyplot as plt\nimport csv\nimport os\n\n# Vanilla GAN model\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path, log_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    \n    # Create log directory if it doesn't exist\n    os.makedirs(os.path.dirname(log_path), exist_ok=True)\n\n    # Open the log file\n    with open(log_path, mode='w', newline='') as log_file:\n        log_writer = csv.writer(log_file)\n        # Write the header\n        log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n        \n        for epoch in range(epochs):\n            # Train Discriminator\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n            discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n            discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n            \n            # Train Generator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            generator_loss = gan.train_on_batch(noise, real_labels)\n            \n            # Log losses\n            print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n            log_writer.writerow([epoch, discriminator_loss[0], generator_loss])\n            vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n            vgan_losses['generator_loss'].append(generator_loss)\n\n            if epoch % 1000 == 0:\n                save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), \n                             path=f\"/workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n\n    # Save the entire GAN model\n    gan.save(save_path)\n\nepochs = 10000\nbatch_size = 64\n\ndef save_images(images, path='/workspace/dataset/chest_xray/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\n# Define the log path\nlog_path = '/workspace/dataset/chest_xray/training_logs.csv'\n\n# Train the GAN with the log path\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size, \n           '/workspace/dataset/chest_xray/lungs_generator_model.h5', log_path)\n","recorded":"2024-10-23 15:18:02.274697649","filePath":"null","pinned":false},{"value":"workspace/dataset/chest_xray/lungs_generator_weights2.h5","recorded":"2024-10-23 15:17:41.112533238","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[10], line 2\n      1 saved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_weights2.h5\"\n----\u003e 2 model = tf.keras.models.load_model(saved_model_path)\n      4 training_history = model.history.history\n      6 # Get generator and discriminator losses\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/saving/saving_api.py:262, in load_model(filepath, custom_objects, compile, safe_mode, **kwargs)\n    254     return saving_lib.load_model(\n    255         filepath,\n    256         custom_objects=custom_objects,\n    257         compile=compile,\n    258         safe_mode=safe_mode,\n    259     )\n    261 # Legacy case.\n--\u003e 262 return legacy_sm_saving_lib.load_model(\n    263     filepath, custom_objects=custom_objects, compile=compile, **kwargs\n    264 )\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/utils/traceback_utils.py:70, in filter_traceback.\u003clocals\u003e.error_handler(*args, **kwargs)\n     67     filtered_tb = _process_traceback_frames(e.__traceback__)\n     68     # To get the full stack trace, call:\n     69     # `tf.debugging.disable_traceback_filtering()`\n---\u003e 70     raise e.with_traceback(filtered_tb) from None\n     71 finally:\n     72     del filtered_tb\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/saving/legacy/hdf5_format.py:197, in load_model_from_hdf5(filepath, custom_objects, compile)\n    195 model_config = f.attrs.get(\"model_config\")\n    196 if model_config is None:\n--\u003e 197     raise ValueError(\n    198         f\"No model config found in the file at {filepath}.\"\n    199     )\n    200 if hasattr(model_config, \"decode\"):\n    201     model_config = model_config.decode(\"utf-8\")\n\nValueError: No model config found in the file at \u003ctensorflow.python.platform.gfile.GFile object at 0x798a1043efd0\u003e.","recorded":"2024-10-23 15:16:50.971438848","filePath":"null","pinned":false},{"value":"saved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_weights2.h5\"\nmodel = tf.keras.models.load_model(saved_model_path)\n\ntraining_history = model.history.history\n\n# Get generator and discriminator losses\ngenerator_loss = training_history['generator_loss']\ndiscriminator_loss = training_history['discriminator_loss']","recorded":"2024-10-23 15:16:45.900218321","filePath":"null","pinned":false},{"value":"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models, optimizers\nimport matplotlib.pyplot as plt\nimport csv\nimport os\n\n# Vanilla GAN model\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path, log_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    \n    # Create log directory if it doesn't exist\n    os.makedirs(os.path.dirname(log_path), exist_ok=True)\n\n    # Open the log file\n    with open(log_path, mode='w', newline='') as log_file:\n        log_writer = csv.writer(log_file)\n        # Write the header\n        log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n        \n        for epoch in range(epochs):\n            # Train Discriminator\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n            discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n            discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n            \n            # Train Generator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            generator_loss = gan.train_on_batch(noise, real_labels)\n            \n            # Log losses\n            print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n            log_writer.writerow([epoch, discriminator_loss[0], generator_loss])\n            vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n            vgan_losses['generator_loss'].append(generator_loss)\n\n            if epoch % 1000 == 0:\n                save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), \n                             path=f\"/workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n\n    # Save generator weights\n    generator.save_weights(save_path)\n\nepochs = 10000\nbatch_size = 64\n\ndef save_images(images, path='/workspace/dataset/chest_xray/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\n# Define the log path\nlog_path = '/workspace/dataset/chest_xray/training_logs.csv'\n\n# Train the GAN with the log path\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size, \n           '/workspace/dataset/chest_xray/lungs_generator_weights2.h5', log_path)\n","recorded":"2024-10-23 15:16:40.267587080","filePath":"null","pinned":false},{"value":"tf.keras.models.load_model(save_path)","recorded":"2024-10-23 15:15:38.242544530","filePath":"null","pinned":false},{"value":"# Example of getting losses after training\ntraining_history = {'generator_loss': vgan_losses['generator_loss'], 'discriminator_loss': vgan_losses['discriminator_loss']}\ngenerator_loss = training_history['generator_loss']\ndiscriminator_loss = training_history['discriminator_loss']","recorded":"2024-10-23 15:15:12.522462191","filePath":"null","pinned":false},{"value":"import tensorflow as tf\n\nsaved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_model.h5\"\nmodel = tf.keras.models.load_model(saved_model_path)\n\n# Accessing training history requires saving it separately, as it is not part of the model\n# Example: loading from a CSV file where you saved it during training\nimport pandas as pd\n\nlog_path = '/workspace/dataset/chest_xray/training_logs.csv'\ntraining_history = pd.read_csv(log_path)\n\n# Get generator and discriminator losses\ngenerator_loss = training_history['Generator Loss'].tolist()\ndiscriminator_loss = training_history['Discriminator Loss'].tolist()\n","recorded":"2024-10-23 15:14:30.450980053","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 saved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_weights2.h5\"\n----\u003e 2 model = tf.keras.models.load_model(saved_model_path)\n      3 training_history = model.history.history\n      5 # Get generator and discriminator losses\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/saving/saving_api.py:262, in load_model(filepath, custom_objects, compile, safe_mode, **kwargs)\n    254     return saving_lib.load_model(\n    255         filepath,\n    256         custom_objects=custom_objects,\n    257         compile=compile,\n    258         safe_mode=safe_mode,\n    259     )\n    261 # Legacy case.\n--\u003e 262 return legacy_sm_saving_lib.load_model(\n    263     filepath, custom_objects=custom_objects, compile=compile, **kwargs\n    264 )\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/utils/traceback_utils.py:70, in filter_traceback.\u003clocals\u003e.error_handler(*args, **kwargs)\n     67     filtered_tb = _process_traceback_frames(e.__traceback__)\n     68     # To get the full stack trace, call:\n     69     # `tf.debugging.disable_traceback_filtering()`\n---\u003e 70     raise e.with_traceback(filtered_tb) from None\n     71 finally:\n     72     del filtered_tb\n\nFile /usr/local/lib/python3.11/dist-packages/keras/src/saving/legacy/hdf5_format.py:197, in load_model_from_hdf5(filepath, custom_objects, compile)\n    195 model_config = f.attrs.get(\"model_config\")\n    196 if model_config is None:\n--\u003e 197     raise ValueError(\n    198         f\"No model config found in the file at {filepath}.\"\n    199     )\n    200 if hasattr(model_config, \"decode\"):\n    201     model_config = model_config.decode(\"utf-8\")\n\nValueError: No model config found in the file at \u003ctensorflow.python.platform.gfile.GFile object at 0x798a3057a410\u003e.","recorded":"2024-10-23 15:14:19.150224938","filePath":"null","pinned":false},{"value":"saved_model_path = \"/workspace/dataset/chest_xray/lungs_generator_weights2.h5\"\nmodel = tf.keras.models.load_model(saved_model_path)\ntraining_history = model.history.history\n\n# Get generator and discriminator losses\ngenerator_loss = training_history['generator_loss']\ndiscriminator_loss = training_history['discriminator_loss']","recorded":"2024-10-23 15:14:11.185804051","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/lalitha-j-a9672011b/","recorded":"2024-10-23 15:11:15.447686927","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/priyanka-sharma-p12/","recorded":"2024-10-23 15:10:33.373665656","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/prashar-snigdha/","recorded":"2024-10-23 15:09:46.341044396","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/shreya-padmanabhan/","recorded":"2024-10-23 15:09:02.085985621","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/varshar25/","recorded":"2024-10-23 15:08:16.094438114","filePath":"null","pinned":false},{"value":"https://www.linkedin.com/in/ishudayma/","recorded":"2024-10-23 15:06:52.278131146","filePath":"null","pinned":false},{"value":"ResMed","recorded":"2024-10-23 14:52:54.099645650","filePath":"null","pinned":false},{"value":"workspace/dataset/chest_xray/generated_imagesImproved","recorded":"2024-10-23 13:29:48.152296524","filePath":"null","pinned":false},{"value":"2024-10-23 07:36:57.832679: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1886] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 43598 MB memory:  -\u003e device: 0, name: NVIDIA A40, pci bus id: 0000:ce:00.0, compute capability: 8.6\nWARNING:absl:`lr` is deprecated in Keras optimizer, please use `learning_rate` or use the legacy optimizer, e.g.,tf.keras.optimizers.legacy.Adam.\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[6], line 101\n     98         plt.savefig(f\"{path}generated_image_{i}.png\")\n     99         plt.close()\n--\u003e 101 train_gan(generator, discriminator, gan, real_data, epochs, batch_size,'/workspace/dataset/chest_xray/lungs_generator_weights2.h5')\n\nTypeError: train_gan() missing 1 required positional argument: 'log_path'","recorded":"2024-10-23 13:09:47.746726859","filePath":"null","pinned":false},{"value":"# Vanilla GAN model\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path, log_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    \n    # Create log directory if it doesn't exist\n    os.makedirs(os.path.dirname(log_path), exist_ok=True)\n\n    # Open the log file\n    with open(log_path, mode='w', newline='') as log_file:\n        log_writer = csv.writer(log_file)\n        # Write the header\n        log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n        \n        for epoch in range(epochs):\n            # Train Discriminator\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n            discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n            discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n            \n            # Train Generator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            generator_loss = gan.train_on_batch(noise, real_labels)\n            \n            # Log losses\n            print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n            log_writer.writerow([epoch, discriminator_loss[0], generator_loss])\n            vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n            vgan_losses['generator_loss'].append(generator_loss)\n\n            if epoch % 1000 == 0:\n                save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), \n                             path=f\"/workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n\n    # Save generator weights\n    generator.save_weights(save_path)\n\nepochs=10000\nbatch_size=64\ndef save_images(images, path='/workspace/dataset/chest_xray/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size,'/workspace/dataset/chest_xray/lungs_generator_weights2.h5')\n","recorded":"2024-10-23 13:09:37.435511593","filePath":"null","pinned":false},{"value":"def train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path, log_path):\n    # Create log directory if it doesn't exist\n    os.makedirs(os.path.dirname(log_path), exist_ok=True)\n\n    # Open the log file\n    with open(log_path, mode='w', newline='') as log_file:\n        log_writer = csv.writer(log_file)\n        # Write the header\n        log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n\n        for epoch in range(epochs):\n            for _ in range(batch_size):\n                idx = np.random.randint(0, real_data.shape[0], batch_size)\n                real_images = real_data[idx]\n\n                # Train the discriminator\n                noise = np.random.normal(0, 1, (batch_size, latent_dim))\n                fake_images = generator.predict(noise)\n                epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n                interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n                interpolated_samples = tf.Variable(interpolated_samples, dtype=tf.float32)\n                \n                with tf.GradientTape() as tape:\n                    tape.watch(interpolated_samples)\n                    pred_real = discriminator(real_images)\n                    pred_fake = discriminator(fake_images)\n                    gradient_penalty = gradient_penalty_loss(real_images, fake_images, discriminator)\n                    d_loss = tf.reduce_mean(pred_fake) - tf.reduce_mean(pred_real) + 10 * gradient_penalty\n                \n                grads = tape.gradient(d_loss, discriminator.trainable_weights)\n                discriminator.optimizer.apply_gradients(zip(grads, discriminator.trainable_weights))\n\n            # Train the generator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            g_loss = wgan_gp.train_on_batch(noise, -np.ones((batch_size, 1)))\n\n            # Log losses\n            print(f\"Epoch {epoch}, Discriminator Loss: {d_loss.numpy()}, Generator Loss: {g_loss}\")\n            log_writer.writerow([epoch, d_loss.numpy(), g_loss])\n            wgan_losses['discriminator_loss'].append(d_loss.numpy())\n            wgan_losses['generator_loss'].append(g_loss)\n\n            if epoch % 20 == 0:\n                save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), \n                             path=f\"/workspace/dataset/chest_xray/generated_imagesWGAN1/epoch_{epoch}\")\n\n    # Save generator weights\n    generator.save_weights(save_path)","recorded":"2024-10-23 13:03:49.429649034","filePath":"null","pinned":false},{"value":"def train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path):\n    for epoch in range(epochs):\n        for _ in range(batch_size):\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n\n            # Train the discriminator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n            interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n            interpolated_samples = tf.Variable(interpolated_samples, dtype=tf.float32)\n            with tf.GradientTape() as tape:\n                tape.watch(interpolated_samples)\n                pred_real = discriminator(real_images)\n                pred_fake = discriminator(fake_images)\n                gradient_penalty = gradient_penalty_loss(real_images, fake_images,discriminator)\n                d_loss = tf.reduce_mean(pred_fake) - tf.reduce_mean(pred_real) + 10 * gradient_penalty\n            grads = tape.gradient(d_loss, discriminator.trainable_weights)\n            discriminator.optimizer.apply_gradients(zip(grads, discriminator.trainable_weights))\n\n        # Train the generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        g_loss = wgan_gp.train_on_batch(noise, -np.ones((batch_size, 1)))\n\n        print(f\"Epoch {epoch}, Discriminator Loss: {d_loss}, Generator Loss: {g_loss}\")\n        wgan_losses['discriminator_loss'].append(d_loss)\n        wgan_losses['generator_loss'].append(g_loss)\n        if epoch % 20 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"/workspace/dataset/chest_xray/generated_imagesWGAN1/epoch_{epoch}\")\n\n    generator.save_weights(save_path)","recorded":"2024-10-23 13:03:28.181245694","filePath":"null","pinned":false},{"value":"/workspace/dataset/chest_xray","recorded":"2024-10-23 13:02:21.098520401","filePath":"null","pinned":false},{"value":"#WGAN model\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models, optimizers\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Define the generator\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1))\n    return model\n\n# Define the gradient penalty\ndef gradient_penalty_loss(real_images, fake_images, discriminator):\n    batch_size = tf.shape(real_images)[0]\n\n    # Randomly interpolate between real and fake samples\n    alpha = tf.random.uniform([batch_size, 1, 1, 1], 0.0, 1.0)\n    interpolated = alpha * real_images + (1 - alpha) * fake_images\n\n    with tf.GradientTape() as tape:\n        tape.watch(interpolated)\n        pred_interpolated = discriminator(interpolated)\n\n    gradients = tape.gradient(pred_interpolated, interpolated)\n    gradients_l2_norm = tf.sqrt(tf.reduce_sum(tf.square(gradients), axis=[1, 2, 3]))\n    gradient_penalty = tf.reduce_mean(tf.square(gradients_l2_norm - 1.0))\n\n    return gradient_penalty\n\n# Define the WGAN-GP model\ndef build_wgan_gp(generator, discriminator, latent_dim):\n    z = layers.Input(shape=(latent_dim,))\n    img = generator(z)\n    valid = discriminator(img)\n    return models.Model(z, valid)\n\n# Define parameters\nlatent_dim = 100\n\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss='mse')\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the WGAN-GP\nwgan_gp = build_wgan_gp(generator, discriminator, latent_dim)\n\n# Compile the WGAN-GP\nwgan_gp.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss=lambda y_true, y_pred: -y_pred)\nwgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the WGAN-GP\ndef train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path):\n    for epoch in range(epochs):\n        for _ in range(batch_size):\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n\n            # Train the discriminator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n            interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n            interpolated_samples = tf.Variable(interpolated_samples, dtype=tf.float32)\n            with tf.GradientTape() as tape:\n                tape.watch(interpolated_samples)\n                pred_real = discriminator(real_images)\n                pred_fake = discriminator(fake_images)\n                gradient_penalty = gradient_penalty_loss(real_images, fake_images,discriminator)\n                d_loss = tf.reduce_mean(pred_fake) - tf.reduce_mean(pred_real) + 10 * gradient_penalty\n            grads = tape.gradient(d_loss, discriminator.trainable_weights)\n            discriminator.optimizer.apply_gradients(zip(grads, discriminator.trainable_weights))\n\n        # Train the generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        g_loss = wgan_gp.train_on_batch(noise, -np.ones((batch_size, 1)))\n\n        print(f\"Epoch {epoch}, Discriminator Loss: {d_loss}, Generator Loss: {g_loss}\")\n        wgan_losses['discriminator_loss'].append(d_loss)\n        wgan_losses['generator_loss'].append(g_loss)\n        if epoch % 20 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"/content/drive/My Drive/Lung dataset/generated_imagesWGAN1/epoch_{epoch}\")\n\n    generator.save_weights(save_path)\n\n# Train the WGAN-GP\nepochs = 1000\nbatch_size =64\n\ndef save_images(images, path='/content/drive/My Drive/Lung dataset/generated_imagesWGAN1'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\ntrain_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, '/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights_wgan_gp1.h5')\n","recorded":"2024-10-23 13:02:12.594784467","filePath":"null","pinned":false},{"value":"def train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path, log_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    \n    # Create log directory if it doesn't exist\n    os.makedirs(os.path.dirname(log_path), exist_ok=True)\n\n    # Open the log file\n    with open(log_path, mode='w', newline='') as log_file:\n        log_writer = csv.writer(log_file)\n        # Write the header\n        log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n        \n        for epoch in range(epochs):\n            # Train Discriminator\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n            discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n            discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n            \n            # Train Generator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            generator_loss = gan.train_on_batch(noise, real_labels)\n            \n            # Log losses\n            print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n            log_writer.writerow([epoch, discriminator_loss[0], generator_loss])\n            vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n            vgan_losses['generator_loss'].append(generator_loss)\n\n            if epoch % 1000 == 0:\n                save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), \n                             path=f\"/workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n\n    # Save generator weights\n    generator.save_weights(save_path)","recorded":"2024-10-23 13:01:17.831338061","filePath":"null","pinned":false},{"value":"learning_rate","recorded":"2024-10-23 13:00:54.075018222","filePath":"null","pinned":false},{"value":"def train_gan(generator, discriminator, gan, real_data, epochs, batch_size,save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n        discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n        vgan_losses['generator_loss'].append(generator_loss)\n        if epoch % 1000 == 0:\n          save_images(generator.predict(np.random.normal(0, 1, (25,latent_dim))), path=f\"/workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n    generator.save_weights(save_path)","recorded":"2024-10-23 13:00:27.519605253","filePath":"null","pinned":false},{"value":"# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n\n        # Discriminator training\n        discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        \n        # If the outputs are not tuples, just assign them directly\n        if isinstance(discriminator_loss_real, tuple):\n            discriminator_loss_real_value = discriminator_loss_real[0]\n            discriminator_accuracy_real = discriminator_loss_real[1]\n        else:\n            discriminator_loss_real_value = discriminator_loss_real\n            discriminator_accuracy_real = 0  # or handle it as needed\n\n        if isinstance(discriminator_loss_fake, tuple):\n            discriminator_loss_fake_value = discriminator_loss_fake[0]\n            discriminator_accuracy_fake = discriminator_loss_fake[1]\n        else:\n            discriminator_loss_fake_value = discriminator_loss_fake\n            discriminator_accuracy_fake = 0  # or handle it as needed\n\n        # Combine the losses and accuracies\n        discriminator_loss = 0.5 * (discriminator_loss_real_value + discriminator_loss_fake_value)\n        discriminator_accuracy = 0.5 * (discriminator_accuracy_real + discriminator_accuracy_fake)\n\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n\n        # Log the results\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss}, Discriminator Accuracy: {discriminator_accuracy}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss)\n        vgan_losses['generator_loss'].append(generator_loss)\n        vgan_losses['discriminator_accuracy'].append(discriminator_accuracy)\n\n        # Log to CSV\n        with open(log_file_path, mode='a', newline='') as log_file:\n            log_writer = csv.writer(log_file)\n            log_writer.writerow([epoch, discriminator_loss, discriminator_accuracy, generator_loss, 'N/A'])  # Generator accuracy can be complex to compute.\n\n        if epoch % 1000 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n    \n    generator.save_weights(save_path)\n","recorded":"2024-10-23 12:56:15.792818230","filePath":"null","pinned":false},{"value":"2024-10-23 07:14:14.261599: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1886] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 43598 MB memory:  -\u003e device: 0, name: NVIDIA A40, pci bus id: 0000:ce:00.0, compute capability: 8.6\nWARNING:absl:`lr` is deprecated in Keras optimizer, please use `learning_rate` or use the legacy optimizer, e.g.,tf.keras.optimizers.legacy.Adam.\nWARNING:absl:`lr` is deprecated in Keras optimizer, please use `learning_rate` or use the legacy optimizer, e.g.,tf.keras.optimizers.legacy.Adam.\n2024-10-23 07:14:15.319684: I tensorflow/compiler/xla/stream_executor/cuda/cuda_dnn.cc:442] Loaded cuDNN version 8905\n2024-10-23 07:14:15.411235: I tensorflow/tsl/platform/default/subprocess.cc:304] Start cannot spawn child process: No such file or directory\n\n2/2 [==============================] - 1s 4ms/step\n\n2024-10-23 07:14:15.714699: I tensorflow/tsl/platform/default/subprocess.cc:304] Start cannot spawn child process: No such file or directory\n2024-10-23 07:14:16.327901: E tensorflow/core/grappler/optimizers/meta_optimizer.cc:961] layout failed: INVALID_ARGUMENT: Size of values 0 does not match size of permutation 4 @ fanin shape insequential/dropout/dropout/SelectV2-2-TransposeNHWCToNCHW-LayoutOptimizer\n2024-10-23 07:14:17.508732: I tensorflow/compiler/xla/service/service.cc:168] XLA service 0x7f808c1af080 initialized for platform CUDA (this does not guarantee that XLA will be used). Devices:\n2024-10-23 07:14:17.508758: I tensorflow/compiler/xla/service/service.cc:176]   StreamExecutor device (0): NVIDIA A40, Compute Capability 8.6\n2024-10-23 07:14:17.514387: I tensorflow/compiler/mlir/tensorflow/utils/dump_mlir_util.cc:269] disabling MLIR crash reproducer, set env var `MLIR_CRASH_REPRODUCER_DIRECTORY` to enable.\n2024-10-23 07:14:17.626066: I ./tensorflow/compiler/jit/device_compiler.h:186] Compiled cluster using XLA!  This line is logged at most once for the lifetime of the process.\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[6], line 118\n    115 batch_size = 64\n    117 # Start training the GAN\n--\u003e 118 train_gan(generator, discriminator, gan, real_data, epochs, batch_size, 'workspace/dataset/chest_xray/lungs_generator_weights2.h5')\n\nCell In[6], line 89, in train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path)\n     86 generator_loss = gan.train_on_batch(noise, real_labels)\n     88 # Log the results\n---\u003e 89 print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Discriminator Accuracy: {discriminator_accuracy}, Generator Loss: {generator_loss}\")\n     90 vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n     91 vgan_losses['generator_loss'].append(generator_loss)\n\nIndexError: invalid index to scalar variable.","recorded":"2024-10-23 12:55:56.909570122","filePath":"null","pinned":false},{"value":"import numpy as np\nimport os\nimport matplotlib.pyplot as plt\nfrom tensorflow import keras\nfrom tensorflow.keras import layers, models, optimizers\n\n# Build the Generator\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\n# Hyperparameters\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': [], 'discriminator_accuracy': [], 'generator_accuracy': []}\n\n# Save logs to a CSV file\nimport csv\n\nlog_file_path = 'gan_training_logs.csv'\nwith open(log_file_path, mode='w', newline='') as log_file:\n    log_writer = csv.writer(log_file)\n    log_writer.writerow(['Epoch', 'Discriminator Loss', 'Discriminator Accuracy', 'Generator Loss', 'Generator Accuracy'])\n\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n\n        # Discriminator training\n        discriminator_loss_real, discriminator_accuracy_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake, discriminator_accuracy_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        \n        discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n        discriminator_accuracy = 0.5 * np.add(discriminator_accuracy_real, discriminator_accuracy_fake)\n\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n\n        # Log the results\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Discriminator Accuracy: {discriminator_accuracy}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n        vgan_losses['generator_loss'].append(generator_loss)\n        vgan_losses['discriminator_accuracy'].append(discriminator_accuracy)\n\n        # Log to CSV\n        with open(log_file_path, mode='a', newline='') as log_file:\n            log_writer = csv.writer(log_file)\n            log_writer.writerow([epoch, discriminator_loss[0], discriminator_accuracy, generator_loss, 'N/A'])  # Generator accuracy can be complex to compute.\n\n        if epoch % 1000 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n    \n    generator.save_weights(save_path)\n\n# Image saving function\ndef save_images(images, path='workspace/dataset/chest_xray/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\n# Training parameters\nepochs = 10000\nbatch_size = 64\n\n# Start training the GAN\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size, 'workspace/dataset/chest_xray/lungs_generator_weights2.h5')\n","recorded":"2024-10-23 12:55:47.991131234","filePath":"null","pinned":false},{"value":"import tensorflow as tf\nfrom tensorflow.keras import layers, models, optimizers\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport csv\n\n# Define the generator\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1))\n    return model\n\n# Define the gradient penalty\ndef gradient_penalty_loss(real_images, fake_images, discriminator):\n    batch_size = tf.shape(real_images)[0]\n\n    # Randomly interpolate between real and fake samples\n    alpha = tf.random.uniform([batch_size, 1, 1, 1], 0.0, 1.0)\n    interpolated = alpha * real_images + (1 - alpha) * fake_images\n\n    with tf.GradientTape() as tape:\n        tape.watch(interpolated)\n        pred_interpolated = discriminator(interpolated)\n\n    gradients = tape.gradient(pred_interpolated, interpolated)\n    gradients_l2_norm = tf.sqrt(tf.reduce_sum(tf.square(gradients), axis=[1, 2, 3]))\n    gradient_penalty = tf.reduce_mean(tf.square(gradients_l2_norm - 1.0))\n\n    return gradient_penalty\n\n# Define the WGAN-GP model\ndef build_wgan_gp(generator, discriminator, latent_dim):\n    z = layers.Input(shape=(latent_dim,))\n    img = generator(z)\n    valid = discriminator(img)\n    return models.Model(z, valid)\n\n# Define parameters\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss='mse')\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the WGAN-GP\nwgan_gp = build_wgan_gp(generator, discriminator, latent_dim)\n\n# Compile the WGAN-GP\nwgan_gp.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss=lambda y_true, y_pred: -y_pred)\n\n# Initialize logs\nwgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n\n# Prepare log file\nlog_file_path = 'wgan_training_logs.csv'\nwith open(log_file_path, mode='w', newline='') as log_file:\n    log_writer = csv.writer(log_file)\n    log_writer.writerow(['Epoch', 'Discriminator Loss', 'Generator Loss'])\n\n# Train the WGAN-GP\ndef train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path):\n    for epoch in range(epochs):\n        for _ in range(batch_size):\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n\n            # Train the discriminator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n            interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n            interpolated_samples = tf.Variable(interpolated_samples, dtype=tf.float32)\n\n            with tf.GradientTape() as tape:\n                tape.watch(interpolated_samples)\n                pred_real = discriminator(real_images)\n                pred_fake = discriminator(fake_images)\n                gradient_penalty = gradient_penalty_loss(real_images, fake_images, discriminator)\n                d_loss = tf.reduce_mean(pred_fake) - tf.reduce_mean(pred_real) + 10 * gradient_penalty\n            \n            grads = tape.gradient(d_loss, discriminator.trainable_weights)\n            discriminator.optimizer.apply_gradients(zip(grads, discriminator.trainable_weights))\n\n        # Train the generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        g_loss = wgan_gp.train_on_batch(noise, -np.ones((batch_size, 1)))\n\n        # Log the results\n        print(f\"Epoch {epoch}, Discriminator Loss: {d_loss.numpy()}, Generator Loss: {g_loss}\")\n        wgan_losses['discriminator_loss'].append(d_loss.numpy())\n        wgan_losses['generator_loss'].append(g_loss)\n\n        # Log to CSV\n        with open(log_file_path, mode='a', newline='') as log_file:\n            log_writer = csv.writer(log_file)\n            log_writer.writerow([epoch, d_loss.numpy(), g_loss])\n\n        if epoch % 20 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"workspace/dataset/chest_xray/generated_imagesWGAN1/epoch_{epoch}\")\n\n    generator.save_weights(save_path)\n\n# Image saving function\ndef save_images(images, path='workspace/dataset/chest_xray/generated_imagesWGAN1'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}/generated_image_{i}.png\")\n        plt.close()\n\n# Train the WGAN-GP\nepochs = 1000\nbatch_size = 64\ntrain_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, 'workspace/dataset/chest_xray/lungs_generator_weights_wgan_gp1.h5')\n","recorded":"2024-10-23 12:41:45.350052454","filePath":"null","pinned":false},{"value":"#WGAN model\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models, optimizers\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Define the generator\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1))\n    return model\n\n# Define the gradient penalty\ndef gradient_penalty_loss(real_images, fake_images, discriminator):\n    batch_size = tf.shape(real_images)[0]\n\n    # Randomly interpolate between real and fake samples\n    alpha = tf.random.uniform([batch_size, 1, 1, 1], 0.0, 1.0)\n    interpolated = alpha * real_images + (1 - alpha) * fake_images\n\n    with tf.GradientTape() as tape:\n        tape.watch(interpolated)\n        pred_interpolated = discriminator(interpolated)\n\n    gradients = tape.gradient(pred_interpolated, interpolated)\n    gradients_l2_norm = tf.sqrt(tf.reduce_sum(tf.square(gradients), axis=[1, 2, 3]))\n    gradient_penalty = tf.reduce_mean(tf.square(gradients_l2_norm - 1.0))\n\n    return gradient_penalty\n\n# Define the WGAN-GP model\ndef build_wgan_gp(generator, discriminator, latent_dim):\n    z = layers.Input(shape=(latent_dim,))\n    img = generator(z)\n    valid = discriminator(img)\n    return models.Model(z, valid)\n\n# Define parameters\nlatent_dim = 100\n\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss='mse')\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the WGAN-GP\nwgan_gp = build_wgan_gp(generator, discriminator, latent_dim)\n\n# Compile the WGAN-GP\nwgan_gp.compile(optimizer=optimizers.RMSprop(lr=0.00005), loss=lambda y_true, y_pred: -y_pred)\nwgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the WGAN-GP\ndef train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path):\n    for epoch in range(epochs):\n        for _ in range(batch_size):\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n\n            # Train the discriminator\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n            epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n            interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n            interpolated_samples = tf.Variable(interpolated_samples, dtype=tf.float32)\n            with tf.GradientTape() as tape:\n                tape.watch(interpolated_samples)\n                pred_real = discriminator(real_images)\n                pred_fake = discriminator(fake_images)\n                gradient_penalty = gradient_penalty_loss(real_images, fake_images,discriminator)\n                d_loss = tf.reduce_mean(pred_fake) - tf.reduce_mean(pred_real) + 10 * gradient_penalty\n            grads = tape.gradient(d_loss, discriminator.trainable_weights)\n            discriminator.optimizer.apply_gradients(zip(grads, discriminator.trainable_weights))\n\n        # Train the generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        g_loss = wgan_gp.train_on_batch(noise, -np.ones((batch_size, 1)))\n\n        print(f\"Epoch {epoch}, Discriminator Loss: {d_loss}, Generator Loss: {g_loss}\")\n        wgan_losses['discriminator_loss'].append(d_loss)\n        wgan_losses['generator_loss'].append(g_loss)\n        if epoch % 20 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), path=f\"workspace/dataset/chest_xray/generated_imagesWGAN1/epoch_{epoch}\")\n\n    generator.save_weights(save_path)\n\n# Train the WGAN-GP\nepochs = 1000\nbatch_size =64\n\ndef save_images(images, path='workspace/dataset/chest_xray/generated_imagesWGAN1'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\ntrain_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, 'workspace/dataset/chest_xray/lungs_generator_weights_wgan_gp1.h5')\n","recorded":"2024-10-23 12:41:13.559475795","filePath":"null","pinned":false},{"value":"# Vanilla GAN model\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size,save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n        discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n        vgan_losses['generator_loss'].append(generator_loss)\n        if epoch % 1000 == 0:\n          save_images(generator.predict(np.random.normal(0, 1, (25,latent_dim))), path=f\"workspace/dataset/chest_xray/generated_imagesImproved/epoch_{epoch}\")\n    generator.save_weights(save_path)\n\nepochs=10000\nbatch_size=64\ndef save_images(images, path='workspace/dataset/chest_xray/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size,'workspace/dataset/chest_xray/lungs_generator_weights2.h5')\n","recorded":"2024-10-23 12:38:30.013030425","filePath":"null","pinned":false},{"value":"# Function to load and preprocess images with labels\ndef load_images_with_labels(folder, img_width, img_height, label):\n    images = []\n    labels = []\n    for filename in os.listdir(folder):\n        img = cv2.imread(os.path.join(folder, filename))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        img = cv2.resize(img, (img_width, img_height))\n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        images.append(img)\n        labels.append(label)\n    return np.array(images), np.array(labels)\n\n# Load and preprocess images with labels\nnormal_images, normal_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height, label=\"Normal\")\npneumonia_images, pneumonia_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height, label=\"Pneumonia\")\n\n\nreal_data = np.concatenate((normal_images, pneumonia_images), axis=0)\nreal_labels = np.concatenate((normal_labels, pneumonia_labels), axis=0)\n\n\nshuffled_indices = np.random.permutation(len(real_data))\nreal_data = real_data[shuffled_indices]\nreal_labels = real_labels[shuffled_indices]\n\n\ndef display_images_with_labels(images, labels, num_samples=5):\n    fig, axes = plt.subplots(1, num_samples, figsize=(15, 3))\n    for i in range(num_samples):\n        axes[i].imshow(images[i][:, :, 0], cmap='gray')\n        axes[i].set_title(labels[i])\n        axes[i].axis('off')\n    plt.show()\n\n\nnum_samples_to_display = 5\ndisplay_images_with_labels(real_data, real_labels, num_samples_to_display)\n","recorded":"2024-10-23 12:33:19.936614744","filePath":"null","pinned":false},{"value":"/workspace/dataset/chest_xray/chest_xray/train/NORMAL/.ipynb_checkpoints","recorded":"2024-10-23 12:31:40.528911593","filePath":"null","pinned":false},{"value":"import os\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Function to load and preprocess images with labels\ndef load_images_with_labels(folder, img_width, img_height, label):\n    images = []\n    labels = []\n    for filename in os.listdir(folder):\n        img_path = os.path.join(folder, filename)\n        img = cv2.imread(img_path)\n        \n        # Check if the image was loaded correctly\n        if img is None:\n            print(f\"Warning: Failed to load image: {img_path}\")\n            continue\n        \n        # Convert to grayscale\n        try:\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        except cv2.error as e:\n            print(f\"Error converting image {filename} to grayscale: {e}\")\n            continue\n        \n        # Resize the image\n        img = cv2.resize(img, (img_width, img_height))\n        \n        # Normalize and expand dimensions for compatibility with models\n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        \n        images.append(img)\n        labels.append(label)\n    \n    return np.array(images), np.array(labels)\n\n# Load and preprocess images with labels\nnormal_images, normal_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height, label=\"Normal\")\npneumonia_images, pneumonia_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height, label=\"Pneumonia\")\n\n# Concatenate data and labels\nreal_data = np.concatenate((normal_images, pneumonia_images), axis=0)\nreal_labels = np.concatenate((normal_labels, pneumonia_labels), axis=0)\n\n# Shuffle data\nshuffled_indices = np.random.permutation(len(real_data))\nreal_data = real_data[shuffled_indices]\nreal_labels = real_labels[shuffled_indices]\n\n# Function to display images with labels\ndef display_images_with_labels(images, labels, num_samples=5):\n    fig, axes = plt.subplots(1, num_samples, figsize=(15, 3))\n    for i in range(num_samples):\n        axes[i].imshow(images[i][:, :, 0], cmap='gray')\n        axes[i].set_title(labels[i])\n        axes[i].axis('off')\n    plt.show()\n\n# Display a sample of images\nnum_samples_to_display = 5\ndisplay_images_with_labels(real_data, real_labels, num_samples_to_display)\n","recorded":"2024-10-23 12:31:25.987231233","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\nerror                                     Traceback (most recent call last)\nCell In[9], line 16\n     13     return np.array(images), np.array(labels)\n     15 # Load and preprocess images with labels\n---\u003e 16 normal_images, normal_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height, label=\"Normal\")\n     17 pneumonia_images, pneumonia_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height, label=\"Pneumonia\")\n     20 real_data = np.concatenate((normal_images, pneumonia_images), axis=0)\n\nCell In[9], line 7, in load_images_with_labels(folder, img_width, img_height, label)\n      5 for filename in os.listdir(folder):\n      6     img = cv2.imread(os.path.join(folder, filename))\n----\u003e 7     img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n      8     img = cv2.resize(img, (img_width, img_height))\n      9     img = img.astype('float32') / 255.0\n\nerror: OpenCV(4.10.0) /io/opencv/modules/imgproc/src/color.cpp:196: error: (-215:Assertion failed) !_src.empty() in function 'cvtColor'","recorded":"2024-10-23 12:31:12.702278326","filePath":"null","pinned":false},{"value":"/workspace/dataset/chest_xray/chest_xray/train/PNEUMONIA/.DS_Store","recorded":"2024-10-23 12:30:24.781001714","filePath":"null","pinned":false},{"value":"/workspace/dataset/chest_xray/chest_xray/train/NORMAL/.DS_Store","recorded":"2024-10-23 12:30:13.285060041","filePath":"null","pinned":false},{"value":"def load_images(folder, img_width, img_height):\n    images = []\n    for filename in os.listdir(folder):\n        img_path = os.path.join(folder, filename)\n        img = cv2.imread(img_path)\n        \n        # Check if the image was loaded correctly\n        if img is None:\n            print(f\"Warning: Failed to load image: {img_path}\")\n            continue\n        \n        # Convert to grayscale\n        try:\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        except cv2.error as e:\n            print(f\"Error converting image {filename} to grayscale: {e}\")\n            continue\n        \n        # Resize the image\n        img = cv2.resize(img, (img_width, img_height))\n        \n        # Normalize and expand dimensions for compatibility with models\n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        \n        images.append(img)\n    \n    return np.array(images)\n\n","recorded":"2024-10-23 12:29:00.844706758","filePath":"null","pinned":false},{"value":"def load_images(folder, img_width, img_height):\n    images = []\n    for filename in os.listdir(folder):\n        img = cv2.imread(os.path.join(folder, filename))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        img = cv2.resize(img, (img_width, img_height)) \n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        images.append(img)\n    return np.array(images)","recorded":"2024-10-23 12:28:34.471436032","filePath":"null","pinned":false},{"value":"for filename in os.listdir(folder):\n    img_path = os.path.join(folder, filename)\n    img = cv2.imread(img_path)\n    if img is None:\n        print(f\"Failed to load image: {img_path}\")\n        continue\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    img = cv2.resize(img, (img_width, img_height)) \n    img = img.astype('float32') / 255.0","recorded":"2024-10-23 12:28:24.829231202","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\nerror                                     Traceback (most recent call last)\nCell In[4], line 7\n      5 get_ipython().system('ls \"/workspace/dataset/chest_xray\"')\n      6 # Load and preprocess images from the dataset\n----\u003e 7 normal_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height)\n      8 pneumonia_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height)\n\nCell In[2], line 5, in load_images(folder, img_width, img_height)\n      3 for filename in os.listdir(folder):\n      4     img = cv2.imread(os.path.join(folder, filename))\n----\u003e 5     img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n      6     img = cv2.resize(img, (img_width, img_height)) \n      7     img = img.astype('float32') / 255.0\n\nerror: OpenCV(4.10.0) /io/opencv/modules/imgproc/src/color.cpp:196: error: (-215:Assertion failed) !_src.empty() in function 'cvtColor'","recorded":"2024-10-23 12:27:30.245014925","filePath":"null","pinned":false},{"value":"workspace/dataset/chest_xray/chest_xray/test","recorded":"2024-10-23 12:24:43.323418224","filePath":"null","pinned":false},{"value":"workspace/dataset/chest_xray","recorded":"2024-10-23 12:18:33.385037471","filePath":"null","pinned":false},{"value":"import os\n\n# List files in the directory to check if path is correct\nprint(os.listdir(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\")))","recorded":"2024-10-23 12:17:01.129420987","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\nerror                                     Traceback (most recent call last)\nCell In[17], line 2\n      1 # Load the dataset\n----\u003e 2 normal_images, normal_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height, label=0)\n      3 pneumonia_images, pneumonia_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height, label=1)\n      5 real_data = np.concatenate((normal_images, pneumonia_images), axis=0)\n\nCell In[15], line 18, in load_images_with_labels(folder, img_width, img_height, label)\n     16 for filename in os.listdir(folder):\n     17     img = cv2.imread(os.path.join(folder, filename))\n---\u003e 18     img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n     19     img = cv2.resize(img, (img_width, img_height))\n     20     img = img.astype('float32') / 255.0\n\nerror: OpenCV(4.10.0) /io/opencv/modules/imgproc/src/color.cpp:196: error: (-215:Assertion failed) !_src.empty() in function 'cvtColor'","recorded":"2024-10-23 12:16:40.518388042","filePath":"null","pinned":false},{"value":"chest_xray","recorded":"2024-10-23 12:15:43.877473448","filePath":"null","pinned":false},{"value":"workspace/kaggle.json","recorded":"2024-10-23 12:09:53.294822331","filePath":"null","pinned":false},{"value":"/workspace","recorded":"2024-10-23 12:09:17.107460049","filePath":"null","pinned":false},{"value":"/home/karna/dotfiles/kaggle.json.cpt","recorded":"2024-10-23 12:08:01.502693641","filePath":"null","pinned":false},{"value":"!pip install kaggle","recorded":"2024-10-23 12:06:24.354750017","filePath":"null","pinned":false},{"value":"dataset","recorded":"2024-10-23 12:05:27.011671097","filePath":"null","pinned":false},{"value":"dataset_dir = \"/content/drive/MyDrive/dataset/chest_xray\"","recorded":"2024-10-23 12:04:49.681158398","filePath":"null","pinned":false},{"value":"!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia -p /content/drive/MyDrive/dataset --unzip\n","recorded":"2024-10-23 12:04:07.764340705","filePath":"null","pinned":false},{"value":"!mkdir -p ~/.kaggle\n!cp kaggle.json ~/.kaggle/\n!chmod 600 ~/.kaggle/kaggle.json\n","recorded":"2024-10-23 12:03:44.255108814","filePath":"null","pinned":false},{"value":"!pip install kaggle\n","recorded":"2024-10-23 12:03:31.625319405","filePath":"null","pinned":false},{"value":"# Plot and save WGAN loss\nplot_loss(wgan_losses)","recorded":"2024-10-23 12:00:03.239619535","filePath":"null","pinned":false},{"value":"train_wgan_gp(generator_wgan, discriminator_wgan, wgan_gp, real_data, epochs, batch_size, save_path_wgan)","recorded":"2024-10-23 11:59:58.732493675","filePath":"null","pinned":false},{"value":"# Train WGAN-GP\ngenerator_wgan = build_generator(latent_dim)\ndiscriminator_wgan = build_discriminator((img_width, img_height, channels))\n\ndiscriminator_wgan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(0.0002, 0.5), metrics=['accuracy'])\nwgan_gp = build_wgan_gp(generator_wgan, discriminator_wgan, latent_dim)\n\nwgan_gp.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(0.0001, 0.5))","recorded":"2024-10-23 11:59:53.988241875","filePath":"null","pinned":false},{"value":"# WGAN Training Function\nwgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n\ndef train_wgan_gp(generator, discriminator, wgan_gp, real_data, epochs, batch_size, save_path):\n    for epoch in range(epochs):\n        for _ in range(batch_size):\n            idx = np.random.randint(0, real_data.shape[0], batch_size)\n            real_images = real_data[idx]\n\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            fake_images = generator.predict(noise)\n\n            epsilon = np.random.uniform(0, 1, (batch_size, 1, 1, 1))\n            interpolated_samples = epsilon * real_images + (1 - epsilon) * fake_images\n\n            d_loss_real = discriminator.train_on_batch(real_images, np.ones((batch_size, 1)))\n            d_loss_fake = discriminator.train_on_batch(fake_images, np.zeros((batch_size, 1)))\n\n            # Generator Training\n            noise = np.random.normal(0, 1, (batch_size, latent_dim))\n            g_loss = wgan_gp.train_on_batch(noise, np.ones((batch_size, 1)))\n\n            wgan_losses['discriminator_loss'].append(d_loss_real + d_loss_fake)\n            wgan_losses['generator_loss'].append(g_loss)\n\n        if epoch % 100 == 0:\n            print(f\"Epoch {epoch}/{epochs}, D Loss: {d_loss_real}, G Loss: {g_loss}\")\n\n        if epoch % 1000 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), f\"/content/drive/My Drive/Lung dataset/generated_imagesWGAN/epoch_{epoch}\")\n\n    generator.save_weights(save_path)\n","recorded":"2024-10-23 11:59:45.288796012","filePath":"null","pinned":false},{"value":"# WGAN-GP Model Definition\ndef build_wgan_gp(generator, discriminator, latent_dim):\n    z = layers.Input(shape=(latent_dim,))\n    img = generator(z)\n    valid = discriminator(img)\n    return models.Model(z, valid)","recorded":"2024-10-23 11:59:39.779711983","filePath":"null","pinned":false},{"value":"# Save and plot loss\ndef plot_loss(vgan_losses, save_dir='/content/drive/My Drive/Lung dataset/loss_plots'):\n    os.makedirs(save_dir, exist_ok=True)\n    plt.figure(figsize=(10, 5))\n    plt.plot(vgan_losses['discriminator_loss'], label='Discriminator Loss', color='blue')\n    plt.plot(vgan_losses['generator_loss'], label='Generator Loss', color='orange')\n    plt.xlabel('Epochs')\n    plt.ylabel('Loss')\n    plt.title('Vanilla GAN Training Losses')\n    plt.legend()\n    plt.savefig(os.path.join(save_dir, 'gan_loss.png'))\n    plt.show()\n\nplot_loss(vgan_losses)","recorded":"2024-10-23 11:59:33.580519643","filePath":"null","pinned":false},{"value":"train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path_gan)","recorded":"2024-10-23 11:59:27.850346119","filePath":"null","pinned":false},{"value":"# Train Vanilla GAN\ngenerator = build_generator(latent_dim)\ndiscriminator = build_discriminator((img_width, img_height, channels))\n\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(0.0002, 0.5), metrics=['accuracy'])\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(0.0001, 0.5))\n\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path_gan)","recorded":"2024-10-23 11:59:22.650139943","filePath":"null","pinned":false},{"value":"# GAN Training Function\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size, save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n\n    for epoch in range(epochs):\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n\n        # Discriminator Training\n        d_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        d_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)\n\n        # Generator Training\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        g_loss = gan.train_on_batch(noise, real_labels)\n\n        vgan_losses['discriminator_loss'].append(d_loss[0])\n        vgan_losses['generator_loss'].append(g_loss)\n\n        if epoch % 100 == 0:\n            print(f\"Epoch {epoch}/{epochs}, D Loss: {d_loss[0]}, G Loss: {g_loss}\")\n\n        if epoch % 1000 == 0:\n            save_images(generator.predict(np.random.normal(0, 1, (25, latent_dim))), f\"/content/drive/My Drive/Lung dataset/generated_imagesImproved/epoch_{epoch}\")\n\n    generator.save_weights(save_path)","recorded":"2024-10-23 11:59:12.614530150","filePath":"null","pinned":false},{"value":"def save_metrics(generator, real_labels, predictions, metrics_dir):\n    os.makedirs(metrics_dir, exist_ok=True)\n    \n    accuracy = accuracy_score(real_labels, predictions)\n    precision = precision_score(real_labels, predictions, average='binary')\n    recall = recall_score(real_labels, predictions, average='binary')\n    f1 = f1_score(real_labels, predictions, average='binary')\n    \n    with open(os.path.join(metrics_dir, 'metrics.txt'), 'w') as f:\n        f.write(f\"Accuracy: {accuracy}\\n\")\n        f.write(f\"Precision: {precision}\\n\")\n        f.write(f\"Recall: {recall}\\n\")\n        f.write(f\"F1-Score: {f1}\\n\")\n\n# Vanilla GAN Model\ndef build_generator(latent_dim):\n    model = models.Sequential([\n        layers.Dense(128 * 16 * 16, input_dim=latent_dim),\n        layers.LeakyReLU(alpha=0.2),\n        layers.Reshape((16, 16, 128)),\n        layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'),\n        layers.LeakyReLU(alpha=0.2),\n        layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'),\n        layers.LeakyReLU(alpha=0.2),\n        layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same')\n    ])\n    return model\n\ndef build_discriminator(input_shape):\n    model = models.Sequential([\n        layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape),\n        layers.LeakyReLU(alpha=0.2),\n        layers.Dropout(0.4),\n        layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'),\n        layers.LeakyReLU(alpha=0.2),\n        layers.Dropout(0.4),\n        layers.Flatten(),\n        layers.Dense(1, activation='sigmoid')\n    ])\n    return model","recorded":"2024-10-23 11:58:59.771958073","filePath":"null","pinned":false},{"value":"# Display sample images\nnum_samples_to_display = 5\ndisplay_images_with_labels(real_data, real_labels, num_samples_to_display)","recorded":"2024-10-23 11:58:54.043670951","filePath":"null","pinned":false},{"value":"# Load the dataset\nnormal_images, normal_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height, label=0)\npneumonia_images, pneumonia_labels = load_images_with_labels(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height, label=1)\n\nreal_data = np.concatenate((normal_images, pneumonia_images), axis=0)\nreal_labels = np.concatenate((normal_labels, pneumonia_labels), axis=0)\n\n# Shuffle dataset\nshuffled_indices = np.random.permutation(len(real_data))\nreal_data, real_labels = real_data[shuffled_indices], real_labels[shuffled_indices]\n\n# Display images and labels\ndef display_images_with_labels(images, labels, num_samples=5):\n    fig, axes = plt.subplots(1, num_samples, figsize=(15, 3))\n    for i in range(num_samples):\n        axes[i].imshow(images[i][:, :, 0], cmap='gray')\n        axes[i].set_title(f\"Label: {labels[i]}\")\n        axes[i].axis('off')\n    plt.show()\n","recorded":"2024-10-23 11:58:47.203338314","filePath":"null","pinned":false},{"value":"# Parameters\nimg_width, img_height, channels = 64, 64, 1\ndataset_dir = \"/content/drive/My Drive/Lung dataset/archive\"\nlatent_dim = 100\nepochs = 10000\nbatch_size = 64\nsave_path_gan = \"/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights.h5\"\nsave_path_wgan = \"/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights_wgan_gp.h5\"\n","recorded":"2024-10-23 11:58:41.217742266","filePath":"null","pinned":false},{"value":"# Load Images\ndef load_images(folder, img_width, img_height):\n    images = []\n    for filename in os.listdir(folder):\n        img = cv2.imread(os.path.join(folder, filename))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        img = cv2.resize(img, (img_width, img_height)) \n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        images.append(img)\n    return np.array(images)\n\n# Load and preprocess images with labels\ndef load_images_with_labels(folder, img_width, img_height, label):\n    images, labels = [], []\n    for filename in os.listdir(folder):\n        img = cv2.imread(os.path.join(folder, filename))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        img = cv2.resize(img, (img_width, img_height))\n        img = img.astype('float32') / 255.0\n        img = np.expand_dims(img, axis=-1)\n        images.append(img)\n        labels.append(label)\n    return np.array(images), np.array(labels)","recorded":"2024-10-23 11:58:25.115630389","filePath":"null","pinned":false},{"value":"import os\nimport cv2\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras import layers, models, optimizers\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n","recorded":"2024-10-23 11:57:47.445430535","filePath":"null","pinned":false},{"value":"latent_dim=100\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\ndef display_generated_images(generator, z_dim, num_images, title):\n    random_latent_vectors = np.random.normal(0, 1, (num_images, z_dim))\n    generated_images = generator.predict(random_latent_vectors)\n\n    # Rescale images to the [0,1] range\n    generated_images = 0.5 * generated_images + 0.5\n\n    plt.figure(figsize=(10, 10))\n    for i in range(num_images):\n        plt.subplot(10, 10, i+1)\n        plt.imshow(generated_images[i, :, :, :])\n        plt.axis('off')\n\n    plt.suptitle(title)\n    plt.show()\n\n\ngenerator_lungs = build_generator(latent_dim)\ngenerator_lungs.load_weights('/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights_wgan_gp.h5')\nprint(generator_lungs.summary())\n# Generate and display cat images\ndisplay_generated_images(generator_lungs, latent_dim, 100, 'Generated Lung Images')","recorded":"2024-10-23 11:53:05.730696317","filePath":"null","pinned":false},{"value":"# for epoch in range(epochs):\n\nplt.figure(figsize=(10, 5))\n\n    # Plot Vanilla GAN losses\nplt.plot(vgan_losses['discriminator_loss'], label='Vanilla GAN - Discriminator Loss', color='blue')\nplt.plot(vgan_losses['generator_loss'], label='Vanilla GAN - Generator Loss', color='orange')\n\n\n\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('GAN Training Losses')\nplt.legend()\nplt.show()","recorded":"2024-10-23 11:52:57.707153821","filePath":"null","pinned":false},{"value":"#GAN model\ndef build_generatorSimple(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\ndef display_generated_images(generator, z_dim, num_images, title):\n    random_latent_vectors = np.random.normal(0, 1, (num_images, z_dim))\n    generated_images = generator.predict(random_latent_vectors)\n\n    # Rescale images to the [0,1] range\n    generated_images = 0.5 * generated_images + 0.5\n\n    plt.figure(figsize=(10, 10))\n    for i in range(num_images):\n        plt.subplot(10, 10, i+1)\n        plt.imshow(generated_images[i, :, :, :])\n        plt.axis('off')\n\n    plt.suptitle(title)\n    plt.show()\n\n\ngenerator_lungs = build_generatorSimple(latent_dim)\ngenerator_lungs.load_weights('/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights.h5')\nprint(generator_lungs.summary())\n# Generate and display cat images\ndisplay_generated_images(generator_lungs, latent_dim, 100, 'Generated Lung Images')","recorded":"2024-10-23 11:52:52.648158548","filePath":"null","pinned":false},{"value":"saved_model_path = \"/content/drive/MyDrive/Lung dataset/archive/lungs_generator_weights2.h5\"\nmodel = tf.keras.models.load_model(saved_model_path)\ntraining_history = model.history.history\n\n# Get generator and discriminator losses\ngenerator_loss = training_history['generator_loss']\ndiscriminator_loss = training_history['discriminator_loss']","recorded":"2024-10-23 11:52:48.442264990","filePath":"null","pinned":false},{"value":"# Vanilla GAN model\ndef build_generator(latent_dim):\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size,save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n        discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n        vgan_losses['generator_loss'].append(generator_loss)\n        if epoch % 1000 == 0:\n          save_images(generator.predict(np.random.normal(0, 1, (25,latent_dim))), path=f\"/content/drive/My Drive/Lung dataset/generated_imagesImproved/epoch_{epoch}\")\n    generator.save_weights(save_path)\n\nepochs=10000\nbatch_size=64\ndef save_images(images, path='/content/drive/My Drive/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size,'/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights2.h5')\n","recorded":"2024-10-23 11:52:42.244270266","filePath":"null","pinned":false},{"value":"img_width, img_height = 64, 64\nchannels = 1  # Grayscale\n\ndataset_dir = \"/content/drive/My Drive/Lung dataset/archive\"\n!ls \"/connt/drive/My Drive/Lung dataset/archizve\"\n# Load and preprocess images from the dataset\nnormal_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height)\npneumonia_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height)","recorded":"2024-10-23 11:52:33.807025394","filePath":"null","pinned":false},{"value":"from google.colab import drive\ndrive.mount('/content/drive')","recorded":"2024-10-23 11:52:30.772763401","filePath":"null","pinned":false},{"value":"import os\nimport cv2\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras import layers, models, optimizers","recorded":"2024-10-23 11:52:18.279024124","filePath":"null","pinned":false},{"value":"https://www.ieltsadvantage.com/2015/03/10/ielts-writing-task-1-grammar-guide/","recorded":"2024-10-23 11:29:34.613496751","filePath":"null","pinned":false},{"value":"/mnt/Karna/aco-main\n/mnt/Karna/CP\n/mnt/Karna/Git\n/mnt/Karna/Motor Imagery Classification Performance Enhancement with EEG Data Augmentation\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main\n/mnt/Karna/Pratik Project GAN Generate lung images\n/mnt/Karna/Reinforcement-learning-approach-for-prognosis-in-ICU\n/mnt/Karna/aco-main.zip\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main.zip","recorded":"2024-10-23 10:36:38.011631544","filePath":"null","pinned":false},{"value":"/10.1016/j.jcp.2018.10.045","recorded":"2024-10-21 16:33:00.580348637","filePath":"null","pinned":false},{"value":"Scopus author profile","recorded":"2024-10-21 16:24:32.801406379","filePath":"null","pinned":false},{"value":"import torch\nimport torch.nn as nn\n\n# Define the generator\nclass Generator(nn.Module):\n    def __init__(self, latent_dim):\n        super(Generator, self).__init__()\n        # Fully connected layer to project latent vector into a 2D shape\n        self.fc = nn.Linear(latent_dim, 128 * 8 * 8)  # Modify this based on your target shape\n        self.lrelu = nn.LeakyReLU(0.2, inplace=True)\n        \n        # Transpose convolutions to upscale the image\n        self.conv_trans1 = nn.ConvTranspose2d(128, 64, kernel_size=4, stride=2, padding=1)  # Output: (batch_size, 64, 16, 16)\n        self.conv_trans2 = nn.ConvTranspose2d(64, 32, kernel_size=4, stride=2, padding=1)   # Output: (batch_size, 32, 32, 32)\n        self.conv_trans3 = nn.ConvTranspose2d(32, 16, kernel_size=4, stride=2, padding=1)   # Output: (batch_size, 16, 64, 64)\n        \n        # Final output layer (e.g., grayscale image)\n        self.conv_out = nn.Conv2d(16, 1, kernel_size=7, padding=3)  # Output: (batch_size, 1, 64, 64)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, z):\n        x = self.fc(z)  # Project the latent vector to a 2D shape\n        x = self.lrelu(x)\n        x = x.view(-1, 128, 8, 8)  # Reshape to (batch_size, 128, 8, 8) for ConvTranspose layers\n        \n        x = self.lrelu(self.conv_trans1(x))  # (batch_size, 64, 16, 16)\n        x = self.lrelu(self.conv_trans2(x))  # (batch_size, 32, 32, 32)\n        x = self.lrelu(self.conv_trans3(x))  # (batch_size, 16, 64, 64)\n        x = self.sigmoid(self.conv_out(x))   # (batch_size, 1, 64, 64)\n        \n        return x","recorded":"2024-10-21 15:36:01.577885091","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\n\nRuntimeError                              Traceback (most recent call last)\n\n\u003cipython-input-18-565860103019\u003e in \u003ccell line: 1\u003e()\n----\u003e 1 train_gan(generator, discriminator, dataloader, epochs, latent_dim, '/content/drive/My Drive/Lung dataset/generated_images')\n\n6 frames\n\n/usr/local/lib/python3.10/dist-packages/torch/nn/modules/linear.py in forward(self, input)\n    115 \n    116     def forward(self, input: Tensor) -\u003e Tensor:\n--\u003e 117         return F.linear(input, self.weight, self.bias)\n    118 \n    119     def extra_repr(self) -\u003e str:\n\nRuntimeError: mat1 and mat2 shapes cannot be multiplied (6400x1 and 100x32768)","recorded":"2024-10-21 15:35:21.146513092","filePath":"null","pinned":false},{"value":"import torch\nimport torch.nn as nn\n\n# Define the generator\nclass Generator(nn.Module):\n    def __init__(self, latent_dim):\n        super(Generator, self).__init__()\n        self.fc = nn.Linear(latent_dim, 128 * 16 * 16)\n        self.lrelu = nn.LeakyReLU(0.2, inplace=True)\n        self.conv_trans1 = nn.ConvTranspose2d(128, 128, kernel_size=4, stride=2, padding=1)\n        self.conv_trans2 = nn.ConvTranspose2d(128, 128, kernel_size=4, stride=2, padding=1)\n        self.conv_out = nn.Conv2d(128, 1, kernel_size=7, padding=3)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, z):\n        x = self.fc(z)\n        x = self.lrelu(x)\n        x = x.view(-1, 128, 16, 16)  # Reshape to (batch_size, 128, 16, 16)\n        x = self.lrelu(self.conv_trans1(x))\n        x = self.lrelu(self.conv_trans2(x))\n        x = self.sigmoid(self.conv_out(x))\n        return x\n\nlatent_dim = 100\ngenerator = Generator(latent_dim)","recorded":"2024-10-21 15:34:05.212110566","filePath":"null","pinned":false},{"value":"---------------------------------------------------------------------------\n\nRuntimeError                              Traceback (most recent call last)\n\n\u003cipython-input-13-565860103019\u003e in \u003ccell line: 1\u003e()\n----\u003e 1 train_gan(generator, discriminator, dataloader, epochs, latent_dim, '/content/drive/My Drive/Lung dataset/generated_images')\n\n9 frames\n\n/usr/local/lib/python3.10/dist-packages/torch/nn/modules/linear.py in forward(self, input)\n    115 \n    116     def forward(self, input: Tensor) -\u003e Tensor:\n--\u003e 117         return F.linear(input, self.weight, self.bias)\n    118 \n    119     def extra_repr(self) -\u003e str:\n\nRuntimeError: mat1 and mat2 shapes cannot be multiplied (6400x1 and 100x32768)","recorded":"2024-10-21 15:33:29.572857291","filePath":"null","pinned":false},{"value":"# Save model weights\ntorch.save(generator.state_dict(), '/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights.pth')\n","recorded":"2024-10-21 15:32:44.118202991","filePath":"null","pinned":false},{"value":"\ntrain_gan(generator, discriminator, dataloader, epochs, latent_dim, '/content/drive/My Drive/Lung dataset/generated_images')\n\n# Save model weights\ntorch.save(generator.state_dict(), '/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights.pth')\n","recorded":"2024-10-21 15:26:36.359391248","filePath":"null","pinned":false},{"value":"epochs = 10000\nbatch_size = 64\n\ndef train_gan(generator, discriminator, dataloader, epochs, latent_dim, save_path):\n    for epoch in range(epochs):\n        for i, real_images in enumerate(dataloader):\n            real_images = real_images.to(device)\n\n            # Train Discriminator\n            optimizer_D.zero_grad()\n            batch_size = real_images.size(0)\n            real_labels = torch.ones(batch_size, 1).to(device)\n            fake_labels = torch.zeros(batch_size, 1).to(device)\n\n            outputs = discriminator(real_images)\n            d_loss_real = adversarial_loss(outputs, real_labels)\n\n            z = torch.randn(batch_size, latent_dim, 1, 1).to(device)\n            fake_images = generator(z)\n            outputs = discriminator(fake_images.detach())\n            d_loss_fake = adversarial_loss(outputs, fake_labels)\n\n            d_loss = d_loss_real + d_loss_fake\n            d_loss.backward()\n            optimizer_D.step()\n\n            # Train Generator\n            optimizer_G.zero_grad()\n            outputs = discriminator(fake_images)\n            g_loss = adversarial_loss(outputs, real_labels)\n            g_loss.backward()\n            optimizer_G.step()\n\n        print(f\"Epoch [{epoch}/{epochs}] - D Loss: {d_loss.item():.4f}, G Loss: {g_loss.item():.4f}\")\n        if epoch % 100 == 0:\n            save_images(fake_images, path=f\"{save_path}/epoch_{epoch}\", num_images=25)\n","recorded":"2024-10-21 15:26:31.106015733","filePath":"null","pinned":false},{"value":"# Function to save generated images\ndef save_images(images, path, num_images=25):\n    grid = vutils.make_grid(images[:num_images], nrow=5, normalize=True)\n    plt.figure(figsize=(10, 10))\n    plt.imshow(np.transpose(grid.cpu().numpy(), (1, 2, 0)))\n    plt.axis('off')\n    os.makedirs(path, exist_ok=True)\n    plt.savefig(f\"{path}/generated_images.png\")\n    plt.close()\n","recorded":"2024-10-21 15:26:23.680078723","filePath":"null","pinned":false},{"value":"\n# Initialize Generator and Discriminator\nlatent_dim = 100\ngenerator = Generator(latent_dim).to(device)\ndiscriminator = Discriminator().to(device)\n\n# Optimizers\nlr = 0.0002\noptimizer_G = optim.Adam(generator.parameters(), lr=lr, betas=(0.5, 0.999))\noptimizer_D = optim.Adam(discriminator.parameters(), lr=lr, betas=(0.5, 0.999))\n\n# Loss function\nadversarial_loss = nn.BCELoss()","recorded":"2024-10-21 15:26:19.255118352","filePath":"null","pinned":false},{"value":"# Define the Discriminator model\nclass Discriminator(nn.Module):\n    def __init__(self):\n        super(Discriminator, self).__init__()\n        self.model = nn.Sequential(\n            nn.Conv2d(1, 64, kernel_size=3, stride=2, padding=1),\n            nn.LeakyReLU(0.2),\n            nn.Dropout(0.4),\n            nn.Conv2d(64, 128, kernel_size=3, stride=2, padding=1),\n            nn.LeakyReLU(0.2),\n            nn.Dropout(0.4),\n            nn.Flatten(),\n            nn.Linear(128 * 16 * 16, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, img):\n        return self.model(img)","recorded":"2024-10-21 15:26:11.197326329","filePath":"null","pinned":false},{"value":"# Define the Generator model\nclass Generator(nn.Module):\n    def __init__(self, latent_dim):\n        super(Generator, self).__init__()\n        self.model = nn.Sequential(\n            nn.Linear(latent_dim, 128 * 16 * 16),\n            nn.LeakyReLU(0.2),\n            nn.Unflatten(1, (128, 16, 16)),\n            nn.ConvTranspose2d(128, 128, kernel_size=4, stride=2, padding=1),\n            nn.LeakyReLU(0.2),\n            nn.ConvTranspose2d(128, 128, kernel_size=4, stride=2, padding=1),\n            nn.LeakyReLU(0.2),\n            nn.Conv2d(128, 1, kernel_size=7, padding=3),\n            nn.Tanh()  # Output is in range [-1, 1]\n        )\n\n    def forward(self, z):\n        return self.model(z)","recorded":"2024-10-21 15:26:05.777196512","filePath":"null","pinned":false},{"value":"# Display sample images\nsample_images = next(iter(dataloader))\ndisplay_images_with_labels(sample_images, num_samples=5)","recorded":"2024-10-21 15:25:56.620628129","filePath":"null","pinned":false},{"value":"\n# Function to display images\ndef display_images_with_labels(images, num_samples=5):\n    fig, axes = plt.subplots(1, num_samples, figsize=(15, 3))\n    for i in range(num_samples):\n        axes[i].imshow(images[i][0], cmap='gray')\n        axes[i].axis('off')\n    plt.show()","recorded":"2024-10-21 15:25:51.227129099","filePath":"null","pinned":false},{"value":"# Combine the datasets\ncombined_dataset = normal_dataset + pneumonia_dataset\ndataloader = DataLoader(combined_dataset, batch_size=64, shuffle=True)","recorded":"2024-10-21 15:25:42.139262685","filePath":"null","pinned":false},{"value":"# Load the datasets\ndataset_dir = \"/content/drive/My Drive/Lung dataset/archive\"\nnormal_dataset = LungDataset(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), 64, 64, transform)\npneumonia_dataset = LungDataset(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), 64, 64, transform)\n","recorded":"2024-10-21 15:25:36.818057651","filePath":"null","pinned":false},{"value":"# Define image transformation (resizing and normalization)\ntransform = transforms.Compose([\n    transforms.Resize((64, 64)),\n    transforms.ToTensor(),\n    transforms.Normalize([0.5], [0.5])  # Normalize to [-1, 1]\n])","recorded":"2024-10-21 15:25:28.273902682","filePath":"null","pinned":false},{"value":"# Dataset class to load and preprocess images\nclass LungDataset(Dataset):\n    def __init__(self, folder, img_width, img_height, transform=None):\n        self.folder = folder\n        self.img_width = img_width\n        self.img_height = img_height\n        self.transform = transform\n        self.image_paths = [os.path.join(folder, fname) for fname in os.listdir(folder)]\n\n    def __len__(self):\n        return len(self.image_paths)\n\n    def __getitem__(self, idx):\n        img_path = self.image_paths[idx]\n        image = Image.open(img_path).convert('L')\n        if self.transform:\n            image = self.transform(image)\n        return image","recorded":"2024-10-21 15:25:22.110850466","filePath":"null","pinned":false},{"value":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","recorded":"2024-10-21 15:25:15.206548255","filePath":"null","pinned":false},{"value":"import os\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader, Dataset\nimport torchvision.transforms as transforms\nimport torchvision.utils as vutils\nimport matplotlib.pyplot as plt\nfrom PIL import Image","recorded":"2024-10-21 15:25:05.905438143","filePath":"null","pinned":false},{"value":"# Vanilla GAN model\ndef build_generator(latent_dim):\n\n    # model = models.Sequential()\n    # model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    # model.add(layers.BatchNormalization())\n    # model.add(layers.LeakyReLU(alpha=0.2))\n    # model.add(layers.Reshape((16, 16, 128)))\n    # model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    # model.add(layers.BatchNormalization())\n    # model.add(layers.LeakyReLU(alpha=0.2))\n    # model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    # model.add(layers.BatchNormalization())\n    # model.add(layers.LeakyReLU(alpha=0.2))\n    # model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    # return model\n    model = models.Sequential()\n    model.add(layers.Dense(128 * 16 * 16, input_dim=latent_dim))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Reshape((16, 16, 128)))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Conv2D(channels, (7, 7), activation='sigmoid', padding='same'))\n    return model\n\n# Define the Discriminator\ndef build_discriminator(input_shape):\n    model = models.Sequential()\n    model.add(layers.Conv2D(64, (3, 3), strides=(2, 2), padding='same', input_shape=input_shape))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Conv2D(128, (3, 3), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU(alpha=0.2))\n    model.add(layers.Dropout(0.4))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1, activation='sigmoid'))\n    return model\n\n# Define the GAN\ndef build_gan(generator, discriminator):\n    discriminator.trainable = False\n    model = models.Sequential()\n    model.add(generator)\n    model.add(discriminator)\n    return model\n\nlatent_dim = 100\ninput_shape = (img_width, img_height, channels)\n\n# Build and compile the discriminator\ndiscriminator = build_discriminator(input_shape)\ndiscriminator.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])\n\n# Build the generator\ngenerator = build_generator(latent_dim)\n\n# Build the GAN\ngan = build_gan(generator, discriminator)\n\ngan.compile(loss='binary_crossentropy', optimizer=optimizers.Adam(lr=0.0001, beta_1=0.5))\nvgan_losses = {'discriminator_loss': [], 'generator_loss': []}\n# Train the GAN\ndef train_gan(generator, discriminator, gan, real_data, epochs, batch_size,save_path):\n    real_labels = np.ones((batch_size, 1))\n    fake_labels = np.zeros((batch_size, 1))\n    for epoch in range(epochs):\n        # Train Discriminator\n        idx = np.random.randint(0, real_data.shape[0], batch_size)\n        real_images = real_data[idx]\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        fake_images = generator.predict(noise)\n        discriminator_loss_real = discriminator.train_on_batch(real_images, real_labels)\n        discriminator_loss_fake = discriminator.train_on_batch(fake_images, fake_labels)\n        discriminator_loss = 0.5 * np.add(discriminator_loss_real, discriminator_loss_fake)\n        # Train Generator\n        noise = np.random.normal(0, 1, (batch_size, latent_dim))\n        generator_loss = gan.train_on_batch(noise, real_labels)\n        print(f\"Epoch {epoch}, Discriminator Loss: {discriminator_loss[0]}, Generator Loss: {generator_loss}\")\n        vgan_losses['discriminator_loss'].append(discriminator_loss[0])\n        vgan_losses['generator_loss'].append(generator_loss)\n        if epoch % 1000 == 0:\n          save_images(generator.predict(np.random.normal(0, 1, (25,latent_dim))), path=f\"/content/drive/My Drive/Lung dataset/generated_imagesImproved/epoch_{epoch}\")\n    generator.save_weights(save_path)\n\nepochs=10000\nbatch_size=64\ndef save_images(images, path='/content/drive/My Drive/generated_imagesImproved/'):\n    os.makedirs(path, exist_ok=True)\n    for i, image in enumerate(images):\n        plt.imshow(image)\n        plt.axis('off')\n        plt.savefig(f\"{path}generated_image_{i}.png\")\n        plt.close()\n\ntrain_gan(generator, discriminator, gan, real_data, epochs, batch_size,'/content/drive/My Drive/Lung dataset/archive/lungs_generator_weights2.h5')\n","recorded":"2024-10-21 15:21:36.672098692","filePath":"null","pinned":false},{"value":"img_width, img_height = 64, 64\nchannels = 1  # Grayscale\n\ndataset_dir = \"/content/drive/My Drive/Lung dataset/archive\"\n!ls \"/connt/drive/My Drive/Lung dataset/archive\"\n# Load and preprocess images from the dataset\nnormal_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height)\npneumonia_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height)","recorded":"2024-10-21 15:21:26.078676251","filePath":"null","pinned":false},{"value":"from tensorflow.keras import layers, models, optimizers","recorded":"2024-10-21 15:21:08.130368589","filePath":"null","pinned":false},{"value":"import os\nimport cv2\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt","recorded":"2024-10-21 15:21:01.221079794","filePath":"null","pinned":false},{"value":"Pratik Gupta","recorded":"2024-10-21 13:16:42.650612739","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Results.zip","recorded":"2024-10-21 13:07:37.042481862","filePath":"null","pinned":false},{"value":"INTRODUCTION\nCancer is a disease brought on by aberrant cells when an internal component is expanding\nout of control. A portion of the body’s cells in all tumors, begin to divide rapidly and\nspread to parts of the neighboring tissues. Among the millions of cells, cancer can appear\nvirtually at any place in the body. Normally, human cells multiply and divide to produce\nnew cells as the body requires them. When a cell becomes damaged or old, it expires and\nis replaced by a fresh cell. But as cancer grows, this systematic mechanism disintegrates.\nOld or injured cells that should have died survive, as cells become more and more erro-\nneous whereas new cells are generated even when they are unwanted. These cells can\ndivide to form new ones, which may lead to tumor-like growth. Solid tumors, or masses\nof tissue, are a common kind of cancer. Leukemias and other blood cancers typically do\nnot develop solid tumors\n1.1\n Oral Cancer\nThe mouth’s cells are the first to develop oral cancer. A cancerous (malignant) nodule is\na group of cancer cells tumor that has the ability to invade neighboring tissue and wreck\nmisery on it. It can also metastasize to different parts of the body. Nodes of lymph in\nthe neck are the part where mouth cancer spreads most frequently. Oral cancer may also\nbe referred to as mouth cancer. Sometimes, cells that are present in the mouth undergo\nchanges and will stop growing or behaving properly. These alterations could result in\nbenign (non-cancerous) tumors like warts and fibromas. Precancerous diseases can also\nbe brought on by changes in the mouth’s cells. This indicates that although the abnormal\ncells are not now cancer, there is a potential that they could develop into cancer if left\n1\nuntreated. Leukoplakia and erythroplakia are two of the most prevalent precancerous\ndisorders of the mouth.\nOral cancer can, however, occasionally result from alterations to the mouth’s cellular\nstructure. The oral mucosa (mucous membrane) is a lining that lines the mouth. The\nsquamous epithelium, which composes the oral mucosa, is made up of squamous cells.\nThese thin, flat squamous cells are where mouth cancer typically begins. The term for\nthis type of cancer is mouth squamous cell carcinoma.\n1.1.1\n Type of Oral Cancer\nThe following organs can develop cancer:\n• Lips\n• Tongue\n• Inner lining of the cheek\n• Gums\n• Mouth Cancer\n• Hard and Soft Palate\n1.2\n Mouth Cancer\nMouth cancer, commonly referred to as oral cancer, happens whenever a tumor forms\ninside the mouth lining. It could be located on the surface of the tongue, the interior of\nthe cheeks, the palate, the lips themselves, or the gums. Additionally, the glands that\ncreate tumors saliva, the tonsils in the rear within the mouth. But these occur frequently.\nSymptoms of mouth cancer:\n• A mouth or lip sore that does not heal\n• An internal mouth patch that is either white or red\n• A growth or bulge inside your mouth; loose teeth;\n• Painful or difficult swallowing\n2\n1.2.1\n Cause of Mouth Cancer\nWhen DNA alterations (mutations) occur in the mouth or lip cells, mouth carcinomas de-\nvelop. DNA includes the instructions for what the cell must accomplish. When normally\nfunctioning cells would die, alterations cause the continued growth and division of the\ncells. The aberrant mouth cancer cells can assemble into a tumor. In time, they might\nspread from the inside of the mouth to the whole body, including the neck or various parts\nof the head.\nMouth cancers tend to start in the flat, thin cells (squamous cells) which define the sur-\nface of the lips and the interior of the mouth. Oral cancer is most frequently caused by\nsquamous cell tumors.\n1.3\n Human Mouth Structure\nThe start of the human mouth is where the lips and skin converge Figure 1.1 shows the\nstructure of the human mouth. The roof of the mouth is made up of both hard and soft\npalates. A soft palate divides the mouth from the nasopharynx (the upper part of the\npharynx), which is connected to the mouth via the oropharynx (the middle section of the\npharynx). The sides of the mouth are formed by the cheeks’ inner surface (De Angeli et\nal. 2022). The majority of the mouth’s floor, or lowest portion, is occupied by the tongue.\nThe mouth can be divided into various sections, including-:\n• The Lips\n• The Tonsils and The Soft Palate\n• The Uvula and the Tongue\n• The buccal mucosa, which coats the cheekbones’ interior\n• The roof of the mouth\n• Teeth, gums, and alveolar ridge, which is the ridge-like border of the jaws that\ncontains the tooth sockets.\n• The Mandible (Lower Jawbone)\n3\nFigure 1.1: Structure of Human mouth\n(German and Palmer 2006)\n1.4\n Diagnosing Techniques for Oral Cancer\nThere are different techniques that are used for the diagnosis of oral cancer, few of the\nclinical techniques used by doctors are discussed below :-\nBarium Swallow: - The voice box, the throat, referral, and surroundings may display\nabnormalities during a barium swallow test, which is also frequently used to find small,\nearly oral tumors.\nBiopsy: - The initial step in identifying mouth cancer is an oral tissue biopsy. A little bit\nof aberrant tissue from the area where oral cancer is suspected is removed by the surgeon\nduring the biopsy. An oral cancer diagnosis may be confirmed by biopsy. The following\ntypes of biopsies are frequently used to identify oral carcinoma:\n• Incisive biopsies: The region has a small amount of tissue taken from it that appears\nto be abnormal. If the abnormal location is easily accessible, the specimen could\nbe obtained at the office of a doctor. If the cancer is more deeply embedded in the\nmouth or throat, biopsy procedures might have to be carried out in a surgical theatre\nwhile receiving anesthesia in order to lessen pain.\n• Exfoliative cytology: Cell samples are gently scraped from a questionable loca-\ntion. To make the cells visible under a microscope, they are put upon a transparent\n4\nslide, and subsequently colored. A deeper biopsy will be done if any cells seem\nsuspicious.\nImage-based tests\n• Computerized Tomography, or CT, Scanning – Information on the size, shape, and\nlocation of any tumors can be obtained via a CT scan, which can help detect lymph\nnodes that are bulging that may contain cancer cells.\n• Magnetic Resonance Imaging (MRI): Oral cancer may be examined with an MRI\nscan, although this is less usual. MRIs give a very thorough picture and may be\nvery helpful in figuring out whether other areas of the body, such as the neck, have\nbeen affected by the disease’s spread.\n• Positron emission computed tomography (PET): Patients with cancer of the oral\ncavity might get a scan using PET technology to find out whether the disease has\nmigrated to the lymph nodes or whether it has only recently progressed to that\nlocation.\n• Genomic testing for advanced oral cancer: -Genomic testing is sometimes known as\nmolecular profiling or cancer sequencing. Examining the collected cells is required\n8 from a biopsy in order to check for any genetic mutations (changes in your DNA)\nthat might be connected to the person’s particular type of cancer.\n1.5\n Oral cancer: Globally\nAmong the most prevalent malignancies worldwide is oral cancer. The majority of cases\nof this subtype of head and neck cancer begin in the cells of squamous tissue that cover\nthe surface of our mouth, tongue, and faces. When this fails to be identified and if not\naddressed in a timely manner, it could be deadly. About 53,000 incidences of oral cancer,\nor three percent of all cancers identified during the study in US annually, are related to\noral cancer. Oral cancer strikes males more frequently than females, more than twice as\noften, and persons over an age of 40 are most at risk.\nSmoking, drinking alcoholic beverages, or having HPV, short for People Papilloma virus\ninfection are the main causes of oral cancer. In 2020, there are expected to be over 177,000\n5\ndeaths globally from lip and oral cavity cancer, In spite of improvements mouth cancer\nfatality rates have remained high in recent decades.\nThe majority of mouth cancer patients, particularly those located in countryside regions,\ncan’t obtain fast, effective diagnosis and treatment, which lowers their chance of survival.\nDepending on race and location, patients with cancer have a five-year living rate among\nthe 50%. According to reports, the survival rate in developed nations can reach 65%.\nIn contrast, leaning upon the area of the mouth cancer affected, a living rate of fifteen\npercent is noted in some countryside areas. It’s because cancer therapy may be highly\nexpensive, especially in later stages. Health experts and the general public both lack a\nsignificant grasp of oral cancer. The 2020 Cancer Statistics Report for India states 66.6\npercent of patients with head and neck cancer had already progressed locally when they\nreceived their diagnosis. Inflammation or ulcers that do not heal, along with discomfort\nand bleeding, are signs of oral cancer.\nOral cancer can be caused by a number of habits, with smoking and drinking being the\ntwo most significant ones. Consuming maggots is so common in India that it causes in-\nternal gum damage.\nGLOBOCAN (Global Cancer Incidence, Mortality and Prevalence) anticipated that in\nFigure 1.2: Global age standardized prevalence of tobacco smoking source World Health\nOrganization\n(Dai, Gakidou, and Lopez 2022)\n2018, there would be 177,384 cancer-related deaths and 354,864 new instances of cancer,\n6\nwhich corresponds to two percent and one point nine percent of all occurrences and fa-\ntalities from cancer, respectively. In summary, mouth cancer, which accounts for around\none-third of all cancer cases, is a major reason for death in Bangladesh, Pakistan, Taiwan,\nand India.\n1.6\n Issues with Oral Cancer Manual Diagnoses\nThe primary problem with manual cancer diagnosis is the delay in diagnosis. It requires\nextremely competent labor, and the number of needed diagnostic tests is increasing dra-\nmatically. Because of the time requirements for a proper diagnosis, it is less likely that\nan early identification of the tumor grade will be made.Pathologists heavy workload is a\nserious worry, and this also affects how well they can anticipate outcomes. It also Prevent\nthe delivery of an accurate diagnosis report as the findings must be carefully crafted to\navoid any fatalities.\n1.7\n Deep Learning\nOne of the main components of an Artificially Intelligent system is learning. Learning\nmeans when a computer program can learn through its surrounding. Artificially intelli-\ngent systems have the ability to mimic the human brain and have the ability to process\ninformation and develop various patterns used to make decisions (Dubuc et al. 2022). A\nsub type of machine learning called \"deep learning\" in artificial intelligence (AI) allows\nnetworks to learn unsupervised from unlabelled input. Deep learning can also refer to\ndeep neural networks or deep learning.\n1.7.1\n Importance of Deep Learning\nMachine learning techniques can now build and learn from a large pool of training data\nbecause to improvements in computer speed and memory over time.\nDeep learning has been a cutting-edge method for humanity, especially when the Informa-\ntion is noisy. Artificial neural networks can learn any function with just one hidden layer,\nregardless of how ambiguous it is, which is why they are regarded as universal function\napproximations.\n7\n1.7.2\n CNN\nConvolutional neural network (CNN) is a subtype of ANN. In at least one of their layers,\nCNN’s replace conventional matrix multiplication methods with the convolution mathe-\nmatical technique. Since they were developed specifically to handle pixel data, they are\nused in image recognition and processing. The design with which CNN is built is compa-\nrable with the model of neural connection like a person’s brain (Jeyaraj, B. K. Panigrahi,\nand Samuel Nadar 2022). Because of the way CNN is built, there are some strong prefer-\nences ingrained in them, which makes it easier to comprehend why they are so effective.\nCNN can be seen as a feed-forward network but having connection with each image can\nFigure 1.3: A CNN Architecture\n(Sun et al. 2019)\nbe inefficient. Therefore, we can prune the useless connection between the hidden layers\nto increase the performance of the layer. A CNN is a special artificial neural network with\nlimited connections between the layers of artificial neural network.\n• Max-Pooling: Each feature map produced by processing the input through many\nlayers of convolution is subsequently combined in a pooling layer. Little grids are\nused for input for pooling procedures, which generate only one value for every re-\ngion. The pooling layers provide CNN significant translational consistency since a\n8\ntiny change in the input image causes a slight modification in the activation maps.\nApplying convolutions with longer strides is another method for obtaining the pool-\ning’s down sampling effect. The network design is made simpler by eliminating the\npooling levels without compromising performance. Max-pooling is the most widely\nemployed of all these pooling techniques.\n• Fully-Connected Layers: Matrix multiplications have traditionally been the build-\ning blocks of neural networks, which are scattered with sigmoid nonlinearities. The\nlayers of the multiplication matrices are referred to as connected layers due to the\nconnection between each unit in the layer before and each unit in the layer af-\nter. There is just small-scale spatial connectivity when using convolutional layers.\nSignificant amounts of completely linked layers are typically avoided in modern\nnetworks since they require massive parameters.\n• Learning algorithm: Lacking an algorithm to quickly and effectively learn the pa-\nrameters of the model, there is little value for an expensive model. Lacking a tech-\nnique for efficiently acquiring the model’s parameters, a strong, expressive model\nis of little use. In the pre-AlexNet era, greedy layer-wise pre-training techniques\nattempted to create such an efficient approach. A more straightforward supervised\ntraining approach is sufficient to learn a reliable model for tasks relating to com-\nputer vision.\n• Optimization Based on Gradient: - Typically, the backpropagation technique is used\nto train networks, which accelerates mathematical calculation to calculate the gra-\ndient used in the Gradient Descent (GD) algorithm. However, employing GD is\nimpracticable for datasets with many hundreds or even more data points. In these\ncircumstances, Stochastic Gradient Descent (SGD), an approximation where gradi-\nents are computed for data points individually rather than the complete data set, is\nfrequently used. Training using SGD generalizes more successfully than with GD,\nit has been discovered.\n• Batch Normalization:- A helpful regularizes that enhances generalisation and sharply\naccelerates convergence is batch normalisation (BN). The order of presentation of\nthe inputs to each layer varies continuously during the training phase, which is a\nproblem caused by inner covariate variation. This effect typically causes training\n9\nto take longer and requires careful initialization. This problem is addressed by BN,\nwhich normalises a layer’s production stimulation to ensure that its spectrum is\nconstrained to a restricted range. In particular, BN normalises each mini-batch’s\nmean-variance statistics using its running average. Recently, BN has been recog-\nnised as a crucial element of very deep networks.\n• Activation layer :- Deep networks typically have convolutions after each layer,\nwhich then follows a nonlinear process. This is required because convolutions are\nan example of a cascading linear system. Layer-to-layer nonlinearities make the\nmodel more evocative than a model with linear dynamics. Theoretically, as long\nas nonlinearities are ongoing bounded, and gradually rising, no nonlinearity has a\ngreater capacity for expressiveness than any other. The sigmoid or the tanh were\nnonlinearities employed in classical neural networks that feed forward. However,\nthe Rectified Linear Unit (ReLU) is used in contemporary convolutional networks.\nIt has been discovered that CNNs with this nonlinearity train more quickly. The\nleaky- ReLU is a brand-new category of nonlinearity that has lately been intro-\nduced. Leaky-ReLU(x) = max(0, x) + min(0, x) is its formula, where is a preset\nparameter. It is better since it implies that the characteristic can also be taught,\ncreating a model that is considerably deeper. Leaky ReLUs or adjustable ReLUs\nare examples of variations on ReLU(z)=max (0; z). The feature maps, which are\nfrequently also referred to as feature maps, are fed through a process of activation\nto create new tensors.\n1.7.3\n Working on Deep Learning Networks\nSince most deep learning methods rely on neural network topologies, they are referred\ndescribed as \"deep neural networks\".\nNormal neural nets only have a few hidden levels, whereas deeper networks may contain\nup to 150 layers. Very vast quantity of categorised autonomously generated data and neu-\nral network topology extract features.\na) Training from Scratch:- For a deep network to be trained from beginning, a very large\nlabelled data set must be gathered, and a network architecture must be created that will\nallow the network to gain insight into its characteristics and predict. This is advantageous\nfor newly developed apps or applications with numerous output categories. This is a less\n10\nfrequent strategy because these networks often take weeks or even months to train be-\ncause to the volume of data and learning rate.\nb) Transfer Learning:- It is a deep learning technique where a pre-trained model is mod-\nified as part of the transfer learning approach. It begins with a reliable network, like\nAlexNet or GoogleNet, then feeds it new values which are previously undiscovered classes.\nThe task can now be carried, out after making network modifications that are minimal.\nMoreover, processing hundreds of photographs as opposed to millions has the advantage\nof requiring much less data, which cuts down computation time to minutes or hours.\nc) Feature Extraction:- The network can be used as a feature extractor, which is a little less\ntypical and a more specialised method of deep learning. Feature Extraction can remove\nspecific features from the network at any point throughout the training process because\nall the layers are charged with learning specific features from images.\n1.7.4\n Purpose of Deep Learning\nThe models developed using Deep Learning have the potential to provide more precise\nand individualised cancer treatment by better predicting the prognosis of the disease. They\nare superior to or on par with the methods now used in clinical settings. Deep learning\ntechniques are anticipated to help in the proper handling of squamous cell carcinoma of\nthe oral cavity through enhanced diagnostic performance, wise clinical decision-making,\nstreamlining of clinicians’ work, the potential for lowering cancer screening costs, and a\nsuccessful evaluation and detection of the disease. In order to increase the quality of care,\nprofessionals and patients can spend more time talking to one another and deliberating\ntogether. Future research should focus on creating deep learning models that integrate\ndiverse datasets from many modalities.\n• Pre –Processing: Due to a variety of factors, the original image will always contain\nsome noise. The accuracy of the diagnosis is compromised by these noises. A cru-\ncial part of the image processing process is pre-processing. Asymmetric filtration is\na filter that is frequently used to enhance grayscale photographs by reducing noise\nand improving image arrangement, particularly edge boundaries.\n• Feature Extraction: - we can generate new features from the previous feature and\nthen we can delete the original features by doing this we can reduce the features\n11\npresent in the dataset. It helps us to categorize the images into different groups.\n• Feature Selection: - Providing a vast amount of features to the model can result\nin a overfitted model with a very high computational time, having a better feature\nextraction will help in reducing the time complexity\nFigure 1.4: Flow chart showing different Phases in detection of oral cancer\n1.8\n Metaheuristic Optimization\nReal-world optimisation issues frequently involve a large number of choice variables, in-\ntricate nonlinear constraints, and difficult objective functions, which makes them more\nand more difficult to solve. Using conventional strategies like numerical methods, the\n12\nglobal optimization is less effective, particularly when limitations or objective functions\ninclude many peaks. Strong instruments for tackling difficult optimisation problems,\nmetaheuristic algorithms are gaining popularity.\nThe simplicity of metaheuristic algorithms is by far their most notable feature. The fun-\ndamental theories or mathematical models underlying these metaheuristic techniques are\nderived from nature. The majority of these techniques are straightforward and simple to\nuse. One can utilise metaheuristics to solve real-world problems thanks to their usability.\nAdditionally, it is simple to create their versions using current techniques.\nThese optimisation technologies can be thought of as \"black boxes,\" capable of providing\na set of outputs for a specific problem for a specific set of inputs. One of the most crucial\naspects of metaheuristic algorithms is randomization. This makes it possible for meta-\nheuristic algorithms to effectively avoid trapping in local optima and to search the whole\nsearch space. More specifically, it enables numerous metaheuristics to handle issues in-\nvolving an ambiguous search space or various local optima. Finally, because of their ex-\ntreme adaptability and flexibility, these metaheuristics can be used to solve a wide range\nof optimisation issues, including non-linear issues, issues involving non-differentiable\nvariables, and issues involving sophisticated numerical calculations and a large number\nof local minima.\n1.9\n Motivation\nThe latest trend in increase of oral cancer is having an adverse effect on health of human\nbeing. Oral cancer can be treated if detected early, with the increase in total number of\ncases of oral cancer we need an accurate and fast way to detect cancer cells. The risk\nof oral cancer is in all age groups but elder people are more prone to it due to unhealthy\nlifestyle. A lot of people have experienced financial troubles. It is crucial for the early\ndiagnosis of disease so that patients can start taking preventative measures right away. AI,\nwhich consists of machine learning and deep learning, is heavily reliant on classification,\ngrading, segmentation, and computer vision. To more or less better model optimisation is\nthe main reason for conducting research in this field.\n• Deep learning concept fascinate me to learn more in this area. Deep learning based\nmodel can detect oral cancer with early signs that can be captured by modern cam-\n13\neras\n• Clinical Images can give an more accurate and fast result as compare to normal\nmethods applied by Doctors\n1.10\n Problem Statement and Research Objective\nA large number of deaths were recorded from oral cancer as a result of lack of its identifi-\ncation and late treatment. Oral cavity cancer has a significant mortality rate that is rising.\nIt is crucial to develop and put into practise a method for detecting this malignancy early\non. By identifying cancer early and adopting preventative measures, it is simple to limit\nthe number of deaths brought on by the disease. Although many researchers have already\nconducted their research in the field of oral cancer disorders, there is still a great deal of\nresearch that may be done in this area owing to performance improvements.\nMachine learning has advanced to the point where getting more use out of it is all but\nimpossible during the last several years. The performance of Deep learning models have\nincreased but there is still a concern of model size, low accuracy and high computation\ntime.\n• To propose and implement optimized Deep learning algorithm for detection of oral\ncancer in it’s early stages.\n• To implement Metaheuristic optimization for better weight selection of clinical im-\nages.\n• To conduct an analysis and compare the proposed approach with state of art models\non basic of evaluation matrices like accuracy, precision, Sensitivity and Specificity.\n1.11\n Thesis outline\nThe chapters of the thesis are organised consistently into an overview, key facts and fig-\nures, significant content, pertinent data, and a final chapter summary. All references are\nincluded at the end and each Figure, table, and piece of text is correctly referenced. The\nfive chapters that make up this thesis are arranged as follows:\n14\n• Chapter 1: It provides a succinct overview of oral cancer, including its kinds, symp-\ntoms, and methods of diagnosis. It describes how the process of making medical\ndiagnoses has been transformed by machine learning, neural networks, and deep\nneural networks. Why has CNN surpassed conventional neural networks? what\nmotivated and inspired you to work in medicine. Additionally, it provides informa-\ntion about the goals and motivation.\n• Chapter 2: It gives a brief overview of the literature for a number of researchers who\nworked on various methods for automatic oral cancer diagnosis, image processing,\nand texture-based categorization. Artificial neural networks, deep learning. A re-\nview of all pertinent theories and techniques for diagnosing oral cancer that are\navailable in the literature.\n• Chapter 3: The chapter sheds insight on a crucial experiment study and the approach\nused to carry out our investigation. The models and various detection architectures\nemployed by CNN have been described. The proposed model is covered in this\nchapter; it has fewer parameters and a shallower learning curve than the pretrained\nmodel, but it is more accurate.\n• Chapter 4: With the use of a graph, bar chart, and other presentation approaches,\nall model and performance metric results are shown. The model’s shortcomings are\nthen displayed and contrasted with the suggested model.\n• Chapter 5: The entire work is concluded in the last chapter. This chapter also\ndiscusses how we might enhance our efforts in the future.","recorded":"2024-10-21 13:03:50.213154809","filePath":"null","pinned":false},{"value":"\\address[2]{Department of Computer Science \\\u0026 Engineering, DR. B.R. Ambedkar National Institute of Technology, Jalandhar -- $144027$, India}","recorded":"2024-10-21 12:58:49.563837468","filePath":"null","pinned":false},{"value":"Prognostic tools","recorded":"2024-10-21 12:57:44.248084303","filePath":"null","pinned":false},{"value":"Evolutionary optimization","recorded":"2024-10-21 12:57:36.356951912","filePath":"null","pinned":false},{"value":"Metaheuristic optimization","recorded":"2024-10-21 12:57:25.665484771","filePath":"null","pinned":false},{"value":"Manta Ray Foraging Optimization (MRFO)","recorded":"2024-10-21 12:57:16.333872857","filePath":"null","pinned":false},{"value":"Transfer learning","recorded":"2024-10-21 12:57:06.035801206","filePath":"null","pinned":false},{"value":"Clinical image analysis","recorded":"2024-10-21 12:56:58.668525204","filePath":"null","pinned":false},{"value":"Deep learning","recorded":"2024-10-21 12:56:50.072238422","filePath":"null","pinned":false},{"value":"Oral cancer detection","recorded":"2024-10-21 12:56:45.380432613","filePath":"null","pinned":false},{"value":"Oral cancer constitutes a considerable worldwide health challenge, especially in areas like India, where it is the sixth most common malignancy, resulting in roughly 130,000 deaths each year. Contemporary diagnostic methods, notwithstanding their diversity, encounter constraints in precision, especially in differentiating malignant cells. Recent advancements in deep learning have demonstrated potential in improving diagnostic accuracy, providing a means to decrease false positives and negatives, and facilitating more dependable prognostics and therapy strategies.\n\nDeep learning architectures, despite their computational complexity, have exhibited remarkable efficacy in numerous categorization tasks, including medical image analysis. Image-based deep learning algorithms for oral cancer diagnosis primarily employ two categories of datasets: clinical images and histopathological images. Due to the availability of high-quality imaging tools, clinical images are now more practical for extensive diagnostic applications. Conversely, histopathology images necessitate specialist equipment and high magnification, presenting practical hurdles for general application.\n\nThis research aims to utilize clinical picture datasets to develop a deep learning framework for the identification of oral cancer. We present an optimization-based metaheuristic strategy that integrates numerous pre-trained models, including VGG19, ResNet50, and EfficientNet, to improve prediction reliability. The novelty resides in the utilization of Manta Ray Foraging Optimization (MRFO) to optimize these models. This ensemble method markedly enhances diagnostic performance, attaining accuracy, sensitivity, and specificity ratings of 97.4%, 95.63%, and 94.12%, respectively.\n\nOur research illustrates the efficacy of deep learning in the identification of cancer through clinical imaging, providing a more accessible and efficient alternative. Future research avenues encompass the expansion of this study to multiclass cancer diagnosis and the investigation of evolutionary techniques for enhanced optimization of deep networks.","recorded":"2024-10-21 12:53:56.507944646","filePath":"null","pinned":false},{"value":"histopathological","recorded":"2024-10-21 12:52:36.198872543","filePath":"null","pinned":false},{"value":"Oral cancer remains a significant global health challenge, particularly in regions such as India, where it ranks as the fifth most prevalent cancer, leading to approximately 130,000 fatalities annually. Current diagnostic techniques, though varied, face limitations in their accuracy, particularly in distinguishing cancerous cells. Recent advances in deep learning have shown promise in enhancing diagnostic precision, offering an avenue to reduce false positives and negatives, and enabling more reliable prognostics and therapeutic interventions.\n\nDeep learning architectures, despite their computational complexity, have demonstrated exceptional performance in various classification tasks, including medical image analysis. For oral cancer diagnosis, image-based deep learning models primarily utilize two types of datasets: clinical images and histopathological images. Given the accessibility of high-quality imaging devices, clinical images have become more feasible for large-scale diagnostic applications. In contrast, histopathological images, requiring specialized equipment and high magnification, pose practical challenges in widespread usage.\n\nThis study focuses on leveraging clinical image datasets to build a deep learning framework for the detection of oral cancer. We propose a metaheuristic optimization-based approach, integrating multiple pre-trained models, including VGG19, ResNet50, and EfficientNet, to enhance prediction reliability. The innovation lies in the application of Manta Ray Foraging Optimization (MRFO) to fine-tune these models. This ensemble-based method significantly improves diagnostic performance, achieving accuracy, sensitivity, and specificity scores of 97.4%, 95.63%, and 94.12%, respectively.\n\nOur findings demonstrate the potential of deep learning in clinical image-based cancer detection, offering a more accessible and efficient solution. Future research directions include extending this work to multiclass cancer detection and exploring evolutionary algorithms for further optimization of deep networks.","recorded":"2024-10-21 12:50:40.139528367","filePath":"null","pinned":false},{"value":"Oral cancer is a prevalent and challenging cancer with a high mortality rate. It is the fifth\nmost common cancer in India, with 130,000 fatalities annually. There are a number of\ndiagnostic techniques for oral cancer, however their precision in identifying cancer cells\nis constrained.\nDeep architectures are becoming more popular as a result of their aptitude for solving\ncomplex problems. Deep architectures have proven effective in numerous classification\nproblems. Despite their incredible representational capacity, deep networks are difficult\nto train computationally. Deep learning minimises false-positive and false-negative errors\nin the detection and diagnosis of this condition, creating a new opportunity to provide\npatients with quick and safe prognostics treatments.\nDeep Learning models work on images, for oral cancer there are 2 dominant datasets\nof Clinical Images and Histopathological Images. The dataset used in study is clinical\ndataset, as now a days phones that can click a high quality images are available with ev-\nerybody therefore anyone can click a image and provide to model to check whether the\nimage id cancerous or not, on the other hand creating Histopathalogical images is a big\ntask, these images are taken at 400X magnification and such tools might not be readily\navailable. Therefore this study aims to use a model that can predict the outcome on clini-\ncal images\nHowever, the majority of research relies on a specific model prediction, and the final find-\nings may or may not be reliable. We suggested a metaheuristic optimization-based deep\nlearning technique. We employ many pre-trained models, including VGG19, ResNet50,\nand EfficientNet, using images of oral cancer. To evaluate the performance of the sug-\ngested method, all of the models’ output was compared to it. Various Transfer of Learning\nmodels with Manta Ray Foraging optimisation are used in our studies, and they produce\nbetter outcomes, with accuracy, sensitivity, and specificity ratings of 97.4, 95.63, and\n94.12, respectively. Future work on this project might include detecting multiclass can-\ncer photos and investigating deep network optimisation systems based on evolutionary\ntechniques.","recorded":"2024-10-21 12:49:22.986939210","filePath":"null","pinned":false},{"value":"bind = $mainMod SHIFT, N, exec, $fileManager\n","recorded":"2024-10-21 12:45:32.578800500","filePath":"null","pinned":false},{"value":"# CNN Model\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D\nfrom tensorflow.keras.layers import MaxPooling2D\nfrom tensorflow.keras.layers import Flatten\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras.layers import Dropout\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\n\n# Initialising the CNN\nclassifier = Sequential()\n\n# Step 1 - Convolution\nclassifier.add(Conv2D(32, (3, 3), input_shape = (64, 64, 3), activation = 'relu'))\n\n# Step 2 - Pooling\nclassifier.add(MaxPooling2D(pool_size = (2, 2)))\n\n# Adding a second convolutional layer\nclassifier.add(Conv2D(32, (3, 3), activation = 'relu'))\nclassifier.add(MaxPooling2D(pool_size = (2, 2)))\n\n","recorded":"2024-10-21 12:38:38.407438932","filePath":"null","pinned":false},{"value":"def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n\nn = int(input())\nprint(fib(n))\n","recorded":"2024-10-21 12:37:40.270187376","filePath":"null","pinned":false},{"value":"eyJhbGciOiJSUzI1NiIsImtpZCI6IjcxOGY0ZGY5MmFkMTc1ZjZhMDMwN2FiNjVkOGY2N2YwNTRmYTFlNWYiLCJ0eXAiOiJKV1QifQ.eyJuYW1lIjoiQ2hhZ2FudGkgIFJlZGR5IiwiaXNzIjoiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tL2V4YTItZmIxNzAiLCJhdWQiOiJleGEyLWZiMTcwIiwiYXV0aF90aW1lIjoxNzI5NDkxMTY2LCJ1c2VyX2lkIjoiZGhFNEd1SldoUlZwM0M3Q3JxWk8yYjJ4dGtnMiIsInN1YiI6ImRoRTRHdUpXaFJWcDNDN0NycVpPMmIyeHRrZzIiLCJpYXQiOjE3Mjk0OTQwNzQsImV4cCI6MTcyOTQ5NzY3NCwiZW1haWwiOiJjaGFnYW50aXZlbmthdGFyYW1pcmVkZHkxQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbImNoYWdhbnRpdmVua2F0YXJhbWlyZWRkeTFAZ21haWwuY29tIl19LCJzaWduX2luX3Byb3ZpZGVyIjoicGFzc3dvcmQifX0.nBrwYOnQvc87QZxrIsH0YAuscaqPixgvvNfkzYu-ENc_fmAf1dVlO7Ce4T_GxTIl1yjwQz7hubzgfWSOrNe5ol9fQdAFkdhh8KFFNmMlqw5AdjZ_-rrvIkXkIVdkCb0RfBuh3zJF7QYAy0diPQMVwCwftCG_sCDsDHI7VQw_oA9nh_TuPfS8ZHbzdlzhfUFphm6K7i7M4jAhCRcqcY_SCMRH6h9Gx6lzlFrAyjQqJDVzk6USaeeBwDF2kUSw4_zdLh67H2kkiHKOrpitWMQ4iXa1CvH_COlJjiu26T-EokZBitVextI0OFz9z6qqhm1V78E9LWWY5ggFrhA4ppuDXw","recorded":"2024-10-21 12:31:16.382651156","filePath":"null","pinned":false},{"value":"e","recorded":"2024-10-21 12:28:49.982735639","filePath":"null","pinned":false},{"value":"vim.g.codeium_enabled = false","recorded":"2024-10-21 12:23:42.739653911","filePath":"null","pinned":false},{"value":"config = function ()\n    -- Change '\u003cC-g\u003e' here to any keycode you like.\n    vim.keymap.set('i', '\u003cC-g\u003e', function () return vim.fn['codeium#Accept']() end, { expr = true, silent = true })\n    vim.keymap.set('i', '\u003cc-;\u003e', function() return vim.fn['codeium#CycleCompletions'](1) end, { expr = true, silent = true })\n    vim.keymap.set('i', '\u003cc-,\u003e', function() return vim.fn['codeium#CycleCompletions'](-1) end, { expr = true, silent = true })\n    vim.keymap.set('i', '\u003cc-x\u003e', function() return vim.fn['codeium#Clear']() end, { expr = true, silent = true })\n  end","recorded":"2024-10-21 12:23:03.084152391","filePath":"null","pinned":false},{"value":"vim.g.codeium_disable_bindings = 1","recorded":"2024-10-21 12:22:42.184635808","filePath":"null","pinned":false},{"value":"Clear current suggestion \tcodeium#Clear() \t\u003cC-]\u003e\nNext suggestion \tcodeium#CycleCompletions(1) \t\u003cM-]\u003e\nPrevious suggestion \tcodeium#CycleCompletions(-1) \t\u003cM-[\u003e\nInsert suggestion \tcodeium#Accept() \t\u003cTab\u003e\nManually trigger suggestion \tcodeium#Complete() \t\u003cM-Bslash\u003e\nAccept word from suggestion \tcodeium#AcceptNextWord() \t\u003cC-k\u003e\nAccept line from suggestion \tcodeium#AcceptNextLine() \t\u003cC-l\u003e","recorded":"2024-10-21 12:21:06.836901678","filePath":"null","pinned":false},{"value":"{\n  'Exafunction/codeium.vim',\n  event = 'BufEnter'\n}","recorded":"2024-10-21 12:20:15.441259524","filePath":"null","pinned":false},{"value":"cursor.sh","recorded":"2024-10-21 11:42:12.978260554","filePath":"null","pinned":false},{"value":"workspace_swipe_direction_lock","recorded":"2024-10-21 11:39:14.431692895","filePath":"null","pinned":false},{"value":"Institute","recorded":"2024-10-20 17:03:37.368255083","filePath":"null","pinned":false},{"value":"Technology","recorded":"2024-10-20 17:03:32.239256667","filePath":"null","pinned":false},{"value":"DR. B.R. AMBEDKAR NATIONAL INSTITUTE OF TECHNOLOGY","recorded":"2024-10-20 17:03:16.693009910","filePath":"null","pinned":false},{"value":"Department of Computer Science \\\u0026 Engineering","recorded":"2024-10-20 17:03:05.839678702","filePath":"null","pinned":false},{"value":"\\address[3]{Faculty of Sciences and Mathematics, University of Ni\\v s, Vi\\v segradska 33, 18000 Ni\\v s, Serbia}","recorded":"2024-10-20 17:02:48.931873839","filePath":"null","pinned":false},{"value":"/mnt/Windows/Documents and Settings/chaga/Downloads/Transfer/(58) Evaluating Web Metrics to Enhance Web Page Quality.pptx","recorded":"2024-10-20 14:38:36.203395895","filePath":"null","pinned":false},{"value":"/mnt/Windows/Documents and Settings/chaga/Downloads/Transfer/(166) Blockchain-Driven Roundabout Production Network.pptx","recorded":"2024-10-20 14:38:25.752314342","filePath":"null","pinned":false},{"value":"Mukesh","recorded":"2024-10-19 19:05:29.731382357","filePath":"null","pinned":false},{"value":"Assistant Professor","recorded":"2024-10-19 19:05:20.119179976","filePath":"null","pinned":false},{"value":"Aman Chandra Kaushik","recorded":"2024-10-19 19:01:17.834488447","filePath":"null","pinned":false},{"value":"+86-15618987739","recorded":"2024-10-19 19:01:03.863543452","filePath":"null","pinned":false},{"value":"Jiangsu,","recorded":"2024-10-19 19:00:22.145628204","filePath":"null","pinned":false},{"value":"No. 1800, Li Lake Avenue","recorded":"2024-10-19 19:00:17.164427989","filePath":"null","pinned":false},{"value":"School of Medicine, Jiangnan University","recorded":"2024-10-19 19:00:08.021786114","filePath":"null","pinned":false},{"value":"Rakesh Prasad","recorded":"2024-10-19 18:57:45.502644311","filePath":"null","pinned":false},{"value":"Jeedimetla ","recorded":"2024-10-19 18:52:47.846436967","filePath":"null","pinned":false},{"value":"Bahadurpally","recorded":"2024-10-19 18:52:41.152402121","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Venkat LoR - University of Maryland_Rakesh.pdf","recorded":"2024-10-19 18:42:36.771026937","filePath":"null","pinned":false},{"value":"Venkat LoR - University of Maryland_Rakesh","recorded":"2024-10-19 18:42:19.481414719","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/LoR - Venkat_Rakesh.pdf","recorded":"2024-10-19 18:41:46.134210945","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Masters-Documents/Applications/TAMU/LoR - Venkat_Rakesh.pdf","recorded":"2024-10-19 18:39:33.254839670","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Venkat LoR - University of Maryland_Mann.pdf","recorded":"2024-10-19 18:38:17.047426300","filePath":"null","pinned":false},{"value":"Venkat LoR - University of Maryland_Mann","recorded":"2024-10-19 18:37:48.010101730","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Venkat LoR - University of Maryland_Aman.pdf","recorded":"2024-10-19 18:37:05.807854852","filePath":"null","pinned":false},{"value":"Venkat LoR - University of Maryland_Aman","recorded":"2024-10-19 18:36:59.564463678","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Masters-Documents/Applications/LOR/Aman_Sir_lor.docx\n/mnt/Karna/Git/Masters-Documents/Applications/LOR/Mann_Recommendation_Letter.pdf\n/mnt/Karna/Git/Masters-Documents/Applications/LOR/Rakesh_Recommendation_Letter.pdf","recorded":"2024-10-19 18:35:00.019725221","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Venkat LoR - University of Maryland_Aman.docx\n/home/karna/Downloads/Venkat LoR - University of Maryland_Aman.pdf\n/home/karna/Downloads/Venkat LoR - University of Maryland_Mann.docx\n/home/karna/Downloads/Venkat LoR - University of Maryland_Mann.pdf\n/home/karna/Downloads/Venkat LoR - University of Maryland_Rakesh.docx\n/home/karna/Downloads/Venkat LoR - University of Maryland_Rakesh.pdf","recorded":"2024-10-19 18:34:32.765742089","filePath":"null","pinned":false},{"value":"Venkat LoR - University of Maryland_Mukesh","recorded":"2024-10-19 18:32:38.655115174","filePath":"null","pinned":false},{"value":"Mentoring Venkat on a major project allowed me to observe his exceptional technical acumen and research skills, which have consistently impressed me.  His projects demonstrated his deep understanding of the subject matter and the ability to implement complex methodologies. His initiative to submit this work to a reputed journal reflects his dedication and ambition to contribute to bioinformatics and drug development.\n\nOne of Venkat’s most admirable qualities is his versatility in working independently and within a team. His leadership skills were evident as he effectively coordinated with team members, yet he excelled when tasked with individual responsibilities, ensuring timely and high-quality output in both scenarios. His problem-solving abilities, particularly in improving model performance and integrating diverse datasets, set him apart as a proactive and analytical thinker.\n\nThroughout our collaboration, I have seen Venkat grow immensely in tackling interdisciplinary challenges, combining his machine learning and computational biology expertise to devise innovative solutions. His proficiency in transfer learning techniques and meticulous attention to enhancing model accuracy underscore his technical depth and analytical mindset. While he has shown remarkable progress, further strengthening his statistical foundation will amplify his research potential.","recorded":"2024-10-19 18:29:02.817881970","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Masters-Documents/Applications/UMD/Venkat LoR - University of Maryland_Aman.tex","recorded":"2024-10-19 18:25:47.485855962","filePath":"null","pinned":false},{"value":"Venkat LoR - University of Massachusetts Amherst_Aman","recorded":"2024-10-19 18:25:27.759218536","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Masters-Documents/Applications/UMD/leadership.tex","recorded":"2024-10-19 18:23:42.862162284","filePath":"null","pinned":false},{"value":"https://www.kaggle.com/competitions/npci-credit-card-default-risk-analysis/leaderboard","recorded":"2024-10-19 17:26:31.214129086","filePath":"null","pinned":false},{"value":"https://github.com/Chaganti-Reddy/CJPR-Report.git","recorded":"2024-10-19 16:20:01.346870626","filePath":"null","pinned":false},{"value":"git@github.com:Chaganti-Reddy/CJPR-Report.git","recorded":"2024-10-19 16:19:58.597453011","filePath":"null","pinned":false},{"value":"Hyderabad@2003","recorded":"2024-10-19 13:23:16.002307804","filePath":"null","pinned":false},{"value":"venkataramireddychaganti41@gmail.com","recorded":"2024-10-19 13:23:09.066026227","filePath":"null","pinned":false},{"value":"VEN3150927","recorded":"2024-10-19 12:57:25.455648729","filePath":"null","pinned":false},{"value":"graduate@rice.edu","recorded":"2024-10-19 12:40:38.164596429","filePath":"null","pinned":false},{"value":"mcisnero@rice.edu","recorded":"2024-10-19 12:40:16.589536145","filePath":"null","pinned":false},{"value":"I wanted to let you know that I checked my ASU portal for any unfinished chores after receiving the email below, but I was unable to locate any on my application site. Since I am eager to enroll in the university, could you kindly let me know if there is anything further I need to do to complete the application?","recorded":"2024-10-19 12:13:50.368299329","filePath":"null","pinned":false},{"value":"Just wanted to inform that after receiving the below email, I have checked my ASU portal for any incomplete tasks but couldn't find any in my application portal. So, could you please confirm if anything is pending from myside so that I can finish the application as I am very keen in getting into the university.","recorded":"2024-10-19 12:13:33.715238020","filePath":"null","pinned":false},{"value":"Dear Sir/Madam,\n\nHope this email finds you well\n\n    Just wanted to inform that after receiving the below email, I have checked my ASU portal for any incomplete tasks but couldn't find any in my application portal. So, could you please confirm if anything is pending from myside so that I can finish the application as I am very keen in getting into the university.\n\nThanks \u0026 Regards\nVenkatarami Reddy Chaganti\n\n---------- Forwarded message ---------\nFrom: Chandan on behalf of ASU \u003casu@mail.kaplanpathways.com\u003e\nDate: Fri, Oct 18, 2024 at 6:34 PM\nSubject: Your ASU application is incomplete\nTo: \u003cvenkataramireddychaganti41@gmail.com\u003e\n\n\nView in browser\nKAPLAN INTERNATIONAL IN PARTNERSHIP WITH\nVenkatarami Reddy Chaganti, your ASU application needs further action\nYour application details\nCampus: ASU Tempe campus\n\t\nStart Date: August 2025\nWe have submitted your application to Arizona State University (ASU), but there are still some tasks you need to complete before it can be evaluated.\nYour application is incomplete\nYour application is currently marked as “incomplete.” To find out why, you’ll need to log into your MyASU student portal.\nCheck MyASU student portal\nPlease complete any outstanding tasks as soon as possible. ASU will not consider you for admission until your application is complete. \n\nIf you have recently completed your application, you can ignore this message.\nBy completing your application, you’re taking the first — and most important — step toward joining the inspiring community of 11,000+ international students at ASU.  \n\nWhile you complete your application, check out this video on why Phoenix is a fantastic study destination. \nwhy Connecticut is a fantastic destination to study abroad. \nIf you have any questions, please contact us by replying to this email, or reach out to your agent, IMFS KP Singh education Services pvt ltd. To ensure a quick response, one of my helpful colleagues may reply.\nBest wishes,\n\nChandan Sharma\nDirector of Application Management, US\nKaplan International on behalf of Arizona State University\nABOUT US\nWe are Kaplan International. We help students follow their path to leading universities across the world. We offer access to exceptional teaching, thousands of degrees and deeply rewarding experiences.\n\nKaplan International works in partnership with Arizona State University to provide application counselling and admissions support to international students.\n\nIn the UK, Kaplan International Pathways is the trading name of Kaplan International Colleges UK Ltd.Company No. 05268303. Registered in England. Registered office: Palace House, 3 Cathedral Street London, SE1 9DE, United Kingdom.\n\t\nYOUR SUBSCRIPTION DETAILS\nVenkatarami Reddy Chaganti, you are receiving this email because you have submitted an application to study at Arizona State University.\n\nWe need to keep you informed throughout your application and admission process with important email updates. You can update your details or manage your subscription. Alternatively, you can unsubscribe if you no longer want to receive these updates.\nPrivacy Policy\nKaplan International 2024. All rights reserved.\nFacebook\nTwitter\nInstagram\nYouTube\nLinkedIn\n","recorded":"2024-10-19 12:12:41.420710595","filePath":"null","pinned":false},{"value":"asu@mail.kaplanpathways.com","recorded":"2024-10-19 12:07:06.719742161","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Files/aco-main\n/home/karna/Downloads/Files/CP\n/home/karna/Downloads/Files/Git\n/home/karna/Downloads/Files/Motor Imagery Classification Performance Enhancement with EEG Data Augmentation\n/home/karna/Downloads/Files/Oral-cancer-detection-using-deep-learning-main\n/home/karna/Downloads/Files/Pratik Project GAN Generate lung images\n/home/karna/Downloads/Files/Reinforcement-learning-approach-for-prognosis-in-ICU\n/home/karna/Downloads/Files/aco-main.zip\n/home/karna/Downloads/Files/Bus_Routing_Problems__June_06th__2024_.pdf\n/home/karna/Downloads/Files/format.pptx\n/home/karna/Downloads/Files/Oral-cancer-detection-using-deep-learning-main.zip","recorded":"2024-10-17 17:52:46.816018517","filePath":"null","pinned":false},{"value":"Karna","recorded":"2024-10-17 17:52:29.994697881","filePath":"null","pinned":false},{"value":"Backup","recorded":"2024-10-17 17:46:10.904625718","filePath":"null","pinned":false},{"value":"/run/media/karna/Xtras/EndeavourOS_Endeavour_neo-2024.09.22.iso","recorded":"2024-10-17 17:32:32.021445202","filePath":"null","pinned":false},{"value":"/mnt/Karna/aco-main\n/mnt/Karna/CP\n/mnt/Karna/Git\n/mnt/Karna/Motor Imagery Classification Performance Enhancement with EEG Data Augmentation\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main\n/mnt/Karna/Pratik Project GAN Generate lung images\n/mnt/Karna/Reinforcement-learning-approach-for-prognosis-in-ICU\n/mnt/Karna/aco-main.zip\n/mnt/Karna/Bus_Routing_Problems__June_06th__2024_.pdf\n/mnt/Karna/format.pptx\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main.zip","recorded":"2024-10-17 17:30:49.088953163","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/chaganti-reddy.github.io/static/uploads/resume.tex","recorded":"2024-10-17 12:33:52.255110051","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Books/Quantum Computing/Griffiths - Introduction to quantum mechanics.pdf","recorded":"2024-10-17 12:31:59.750544890","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Evaluating_Web_Metrics_for_Enhancing_WebPage_Quality.pptx\n/home/karna/Downloads/venkat_blockchain_6321.pptx","recorded":"2024-10-17 12:31:09.426441434","filePath":"null","pinned":false},{"value":"haskell-skylighting-format-latex-0.1-135-x86_64                                       29.8 KiB   109 KiB/s 00:00 [--------------------------------------------------------------------] 100%","recorded":"2024-10-17 12:11:28.291771970","filePath":"null","pinned":false},{"value":"haskell-hslua-marshalling-2.3.1-13-x86_64","recorded":"2024-10-17 11:55:35.322241289","filePath":"null","pinned":false},{"value":"haskell-indexed-traversable-0.1.4-4-x86_64","recorded":"2024-10-17 11:55:34.657888545","filePath":"null","pinned":false},{"value":"haskell-fast-logger-3.1.2-85-x86_64","recorded":"2024-10-17 11:55:33.917732938","filePath":"null","pinned":false},{"value":"haskell-hslua-module-doclayout-1.1.0-70-x86_64","recorded":"2024-10-17 11:55:32.836506099","filePath":"null","pinned":false},{"value":"                                       73.6 KiB   116 KiB/s 00:01 [--------------------------------------------------------------------] 100%\n haskell-fas","recorded":"2024-10-17 11:55:31.438995978","filePath":"null","pinned":false},{"value":"haskell-hslua-module-docla","recorded":"2024-10-17 11:55:30.101757100","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/HITA2024/Blockchain-driven Roundabout Production Network/Blockchain_empowered_Roundabout_Production_Network_in_the_Agri-food_Supply_Chain_for_Spanning_Trust_T.pptx","recorded":"2024-10-16 20:38:56.068859882","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/HITA2024/Empirical Validation on Web Pages/Evaluating_Web_Metrics_for_Enhancing_WebPage_Quality_.pptx","recorded":"2024-10-16 20:38:51.148275063","filePath":"null","pinned":false},{"value":"/mnt/Karna/format.pptx","recorded":"2024-10-16 20:37:49.806377121","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/format.pptx","recorded":"2024-10-16 20:37:45.510997482","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Files/aco-main\n/home/karna/Downloads/Files/CP\n/home/karna/Downloads/Files/Git\n/home/karna/Downloads/Files/Motor Imagery Classification Performance Enhancement with EEG Data Augmentation\n/home/karna/Downloads/Files/Oral-cancer-detection-using-deep-learning-main\n/home/karna/Downloads/Files/Pratik Project GAN Generate lung images\n/home/karna/Downloads/Files/Reinforcement-learning-approach-for-prognosis-in-ICU\n/home/karna/Downloads/Files/aco-main.zip\n/home/karna/Downloads/Files/Bus_Routing_Problems__June_06th__2024_.pdf\n/home/karna/Downloads/Files/Oral-cancer-detection-using-deep-learning-main.zip","recorded":"2024-10-16 20:37:19.476187140","filePath":"null","pinned":false},{"value":"Windows","recorded":"2024-10-16 20:35:35.566081274","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Files/Git/HITA2024/Blockchain-driven Roundabout Production Network/Blockchain_empowered_Roundabout_Production_Network_in_the_Agri-food_Supply_Chain_for_Spanning_Trust_T.pptx","recorded":"2024-10-16 16:42:48.866499802","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Files/Git/HITA2024/Empirical Validation on Web Pages/Evaluating_Web_Metrics_for_Enhancing_WebPage_Quality_.pptx","recorded":"2024-10-16 16:42:41.637230516","filePath":"null","pinned":false},{"value":"This study focuses on evaluating key web metrics to enhance the quality of web pages.","recorded":"2024-10-16 16:39:15.007246002","filePath":"null","pinned":false},{"value":"overview","recorded":"2024-10-16 16:33:46.897316240","filePath":"null","pinned":false},{"value":"This study focuses on evaluating key web metrics to enhance the quality of web pages.\nData is sourced from 600 websites nominated for the Webby Awards between 2017 and 2022.\n\nKey performance and quality metrics include:\nSpeed Index\nTotal Blocking Time\nTime to Interactive (TTI)\nFirst Contentful Paint (FCP)\n\nA Python-based automated tool was developed to analyze:\n16 quality measures\n6 performance indicators\n\nWebsites were categorized into high and low quality based on these metrics.\n\nThe findings offer insights into optimizing web design and improving user experiences on online platforms.","recorded":"2024-10-16 14:41:34.168033252","filePath":"null","pinned":false},{"value":"📷 109676-797521221.png","recorded":"2024-10-16 14:40:19.840872922","filePath":"/home/karna/.config/clipse/tmp_files/109676-797521221.png","pinned":false},{"value":"📷 8528-415532030.png","recorded":"2024-10-16 14:39:35.420247983","filePath":"/home/karna/.config/clipse/tmp_files/8528-415532030.png","pinned":false},{"value":"\u003cmeta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"\u003e\u003cimg src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRSSl4axzcEv9vzUQU6zJqcaknKrYeyBb7QYQ\u0026amp;s\" class=\"sFlh5c FyHeAf\" alt=\"Mahindra University | Hyderabad\" jsname=\"JuXqh\" style=\"max-width:761px;\" data-ilt=\"1729069761536\"\u003e","recorded":"2024-10-16 14:39:35.416280525","filePath":"null","pinned":false},{"value":"Mahindra University,","recorded":"2024-10-16 14:38:06.470891760","filePath":"null","pinned":false},{"value":"Rakesh Prasad Badoni","recorded":"2024-10-16 14:37:30.403429629","filePath":"null","pinned":false},{"value":"Evaluating Web Metrics for Enhancing Web Page Quality","recorded":"2024-10-16 14:29:28.853951628","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Files/Internships","recorded":"2024-10-15 13:16:32.871616056","filePath":"null","pinned":false},{"value":"📷 4412-465009130.png","recorded":"2024-10-15 10:55:35.468435878","filePath":"/home/karna/.config/clipse/tmp_files/4412-465009130.png","pinned":false},{"value":"https://catalog.arizona.edu/programs/COSCMS","recorded":"2024-10-15 10:55:35.466170212","filePath":"null","pinned":false},{"value":"📷 3962-572380516.png","recorded":"2024-10-15 10:55:24.575993323","filePath":"/home/karna/.config/clipse/tmp_files/3962-572380516.png","pinned":false},{"value":"https://degrees.apps.asu.edu/masters-phd/major/ASU00/ESCSEBDMS/computer-science-big-data-systems-ms","recorded":"2024-10-15 10:55:24.573466893","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/Win10_22H2_EnglishInternational_x64v1.iso","recorded":"2024-10-14 19:10:15.445627020","filePath":"null","pinned":false},{"value":"/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/boot\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/efi\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/sources\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/support\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/autorun.inf\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/bootmgr\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/bootmgr.efi\n/run/media/karna/CCCOMA_X64FRE_EN-GB_DV9/setup.exe","recorded":"2024-10-14 18:59:16.981858978","filePath":"null","pinned":false},{"value":"exo-open","recorded":"2024-10-14 18:53:55.910158476","filePath":"null","pinned":false},{"value":"TerminalEmulator","recorded":"2024-10-14 18:53:06.282987859","filePath":"null","pinned":false},{"value":"afc://00008120-0010246C11E8201E:3/org.mozilla.ios.Firefox/Downloads/www.5MovieRulz.top%20-%20Mangalavaaram%20(2023)%201080p%20Telugu%20HQ%20HDRip%20-%20HEVC%20-%20%20(DD%205.1%20-%20192kbps%20_%20AAC)%20-%201.8GB%20-%20ESub.mkv.zip","recorded":"2024-10-14 18:48:38.054554017","filePath":"null","pinned":false},{"value":"/mnt/Karna/aco-main\n/mnt/Karna/CP\n/mnt/Karna/Git\n/mnt/Karna/ISRO\n/mnt/Karna/Motor Imagery Classification Performance Enhancement with EEG Data Augmentation\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main\n/mnt/Karna/Pratik Project GAN Generate lung images\n/mnt/Karna/Reinforcement-learning-approach-for-prognosis-in-ICU\n/mnt/Karna/1.mp3\n/mnt/Karna/acknowledgementSlip_S1858416595000.pdf\n/mnt/Karna/aco-main.zip\n/mnt/Karna/Oral-cancer-detection-using-deep-learning-main.zip","recorded":"2024-10-14 18:45:39.154727189","filePath":"null","pinned":false},{"value":"/run/media/karna/Xtras/Win10_22H2_EnglishInternational_x64v1.iso","recorded":"2024-10-14 18:45:22.361748592","filePath":"null","pinned":false},{"value":"#!/bin/bash\nnotify_levels=(3 5 10 20)\nBAT=$(ls /sys/class/power_supply |grep BAT |head -n 1)\nlast_notify=100\n\nwhile true; do\n    bat_lvl=$(cat /sys/class/power_supply/${BAT}/capacity)\n    if [ $bat_lvl -gt $last_notify ]; then\n            last_notify=$bat_lvl\n    fi\n    for notify_level in ${notify_levels[@]}; do\n        if [ $bat_lvl -le $notify_level ]; then\n            if [ $notify_level -lt $last_notify ]; then\n                notify-send -u critical \"Low Battery\" \"$bat_lvl% battery remaining.\"\n                last_notify=$bat_lvl\n            fi\n        fi\n    done\nsleep 60\ndone","recorded":"2024-10-11 14:07:39.939515930","filePath":"null","pinned":false},{"value":"/mnt/Karna/Pratik Project GAN Generate lung images/archive.zip","recorded":"2024-10-11 14:04:00.079000123","filePath":"null","pinned":false},{"value":"exec-once = numlockx on \u0026\n","recorded":"2024-10-11 11:12:16.372495951","filePath":"null","pinned":false},{"value":"AA2005233711@@","recorded":"2024-10-10 18:03:28.843983252","filePath":"null","pinned":false},{"value":"ramchaganti200@gmail.com","recorded":"2024-10-10 18:03:24.922993123","filePath":"null","pinned":false},{"value":"https://leetcode.com/discuss/interview-question/5886397/DSA-Patterns-you-need-to-know-!!!","recorded":"2024-10-10 18:01:00.267913418","filePath":"null","pinned":false},{"value":"Minor_Project_Generating_Lung_Images_GAN_network","recorded":"2024-10-10 17:46:32.731696132","filePath":"null","pinned":false},{"value":"            // Bluetooth Devices Bluetooth icon \n","recorded":"2024-10-10 17:30:19.699745624","filePath":"null","pinned":false},{"value":"            \n","recorded":"2024-10-10 17:30:18.833974826","filePath":"null","pinned":false},{"value":"\n","recorded":"2024-10-10 17:30:18.229474834","filePath":"null","pinned":false},{"value":"            \"Bluetooth Devices\": \"\u003cspan foreground='#a6adc8'\u003e󰤯 \u003c/span\u003e Bluetooth Devices\",\n","recorded":"2024-10-10 17:30:17.426970677","filePath":"null","pinned":false},{"value":"            \"(.*)Bluetooth Devices\": \"\u003cspan foreground='#a6adc8'\u003e󰤯 \u003c/span\u003e $1\",\n","recorded":"2024-10-10 17:30:16.423901188","filePath":"null","pinned":false},{"value":"            \"(.*) - Bluetooth Devices\": \"\u003cspan foreground='#f38ba8'\u003e󰅂 \u003c/span\u003e $1\",\n","recorded":"2024-10-10 17:28:37.921056718","filePath":"null","pinned":false},{"value":"            \"Bluetooth Devices\": \"\u003cspan foreground='#f38ba8'\u003e󰅂 \u003c/span\u003e Bluetooth Devices\",\n","recorded":"2024-10-10 17:28:37.615069268","filePath":"null","pinned":false},{"value":"        \"custom/kernelinfo\",\n","recorded":"2024-10-10 17:23:27.113485597","filePath":"null","pinned":false},{"value":"Generating Radiologically Realistic Lung Images\nwith Generative Adversarial Networks","recorded":"2024-10-10 16:20:58.922037573","filePath":"null","pinned":false},{"value":"train","recorded":"2024-10-10 16:10:55.268502000","filePath":"null","pinned":false},{"value":"img_width, img_height = 64, 64\nchannels = 1  # Grayscale\n\ndataset_dir = \"/content/drive/My Drive/Lung dataset/archive\"\n!ls \"/content/drive/My Drive/Lung dataset/archive\"\n# Load and preprocess images from the dataset\nnormal_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/NORMAL\"), img_width, img_height)\npneumonia_images = load_images(os.path.join(dataset_dir, \"chest_xray/train/PNEUMONIA\"), img_width, img_height)","recorded":"2024-10-10 16:06:31.174340605","filePath":"null","pinned":false},{"value":"archive","recorded":"2024-10-10 16:04:57.653750846","filePath":"null","pinned":false},{"value":"Lung dataset","recorded":"2024-10-10 16:04:48.029545501","filePath":"null","pinned":false},{"value":"Reviewer #1: The authors could provide good work. However, there are some concerns to be resolved.","recorded":"2024-10-10 16:01:56.372229701","filePath":"null","pinned":false},{"value":"The abstract needs to be improved. The first sentence in the abstract, it is necessary for the authors to add a sentence to describe the problem or motivation to focus on this topic. The second sentence should provide the literature gap. In the third sentence, the authors should say what you are doing, and then provide the empirical findings. Finally, the significance of the finding should be offered.","recorded":"2024-10-10 16:01:50.999127571","filePath":"null","pinned":false},{"value":"This study addresses the vehicle routing problem (VRP) en-\ncountered by transportation bus service providers with the goal of opti-\nmizing their bus routes. The hypothesis posits that each vehicle should\nreach a pickup point, considered a boarding location, before proceed-\ning to the designated destination. At each pickup point, a list of one or\nmore passengers departing from that specific location exists. The primary\nobjective of this study is to minimize the overall transportation cost by\nenhancing routing efficiency while accounting for application constraints,\ncapacity limitations, and time constraints. To achieve this, we propose a\nmathematical model encompassing various boarding and dropping points\nwith diverse time periods to enhance vehicle routing. The subsequent\nphase focuses on the ant colony optimization algorithm, addressing the\nproblem comprehensively within its expansive scope. Finally, to validate\nthe effectiveness of the proposed algorithm, we conduct tests on real-\nworld data to ascertain its practical viability.","recorded":"2024-10-10 16:01:11.156488946","filePath":"null","pinned":false},{"value":"/home/karna/Downloads/LOR check list .docx","recorded":"2024-10-10 15:58:11.341078197","filePath":"null","pinned":false},{"value":"The strength of Mr. Venkatarami Reddy lies in his ability to adapt and embed his knowledge into various real world problems with his research ability. The same has done under my guidance as well, embedded machine learning in predicting protein structures using Deep Learning techniques. One of the most important and unique skill that I had observed is his ability to work independently as well as working with team. He can complete the work on time in both the scenario, which resembles his team work and leadership.\n\tYes, his work on protein structure prediction using deep learning, specifically with CNNs and transformer-based models, would certainly stand out. He achieved high precision and accuracy which has practical applications in bioinformatics and drug development. His initiative to submit this work to a prestigious journal further underscores his dedication to advancing knowledge in the field.\n\tI would highlight Venkatarami’s problem-solving skills, as demonstrated by his ability to improve model performance and integrate complex datasets. \n\tI have seen significant growth in Venkatarami’s ability to tackle interdisciplinary problems, blending his knowledge of machine learning with computational biology. His technical depth and understanding of advanced models have matured throughout our collaboration, as evidenced by his innovative solutions to complex biological challenges.\n\tStrengthening his statistical knowledge would further enhance his research capabilities, especially in fields requiring rigorous validation and testing.\nCertainly, his proficiency in implementing and optimizing advanced machine learning models, along with his ability to apply techniques like transfer learning, highlights his strong technical and problem-solving skills. He paid close attention to detail in improving model performance and accuracy, which reflects his analytical mindset.","recorded":"2024-10-10 14:58:16.623405641","filePath":"null","pinned":false},{"value":"    11. Can you recall any specific examples of the student's strengths in your class or projects?\n\t\n\tThe strength of Mr. Venkatarami Reddy lies in his ability to adapt and embed his knowledge into various real world problems with his research ability. The same has done under my guidance as well, embedded machine learning in predicting protein structures using Deep Learning techniques.\n\n    12. What qualities do you think graduate admissions committees value most, and how does the student compare?\n\n\tOne of the most important and unique skill that I had observed is his ability to work independently as well as working with team. He can complete the work on time in both the scenario, which resembles his team work and leadership.\n \n    13. Are there any examples of the student's work that you believe would stand out to an admissions committee?\n\t\n\tYes, his work on protein structure prediction using deep learning, specifically with CNNs and transformer-based models, would certainly stand out. He achieved high precision and accuracy which has practical applications in bioinformatics and drug development. His initiative to submit this work to a prestigious journal further underscores his dedication to advancing knowledge in the field.\n\n    14. What specific traits, like problem-solving or teamwork, would you highlight in the student's recommendation?\n\n\tI would highlight Venkatarami’s problem-solving skills, as demonstrated by his ability to improve model performance and integrate complex datasets. \n\n    15. Where have you seen the most academic or professional growth in the student?\n\n\tI have seen significant growth in Venkatarami’s ability to tackle interdisciplinary problems, blending his knowledge of machine learning with computational biology. His technical depth and understanding of advanced models have matured throughout our collaboration, as evidenced by his innovative solutions to complex biological challenges.\n\n    16. What areas should the student work on before starting this program?\n\n\tStrengthening his statistical knowledge would further enhance his research capabilities, especially in fields requiring rigorous validation and testing.\n\n    17. Would you be able to provide examples to support the key skills the student plans to emphasize in their application?\n\nCertainly, his proficiency in implementing and optimizing advanced machine learning models, along with his ability to apply techniques like transfer learning, highlights his strong technical and problem-solving skills. He paid close attention to detail in improving model performance and accuracy, which reflects his analytical mindset. ","recorded":"2024-10-10 14:57:24.794451561","filePath":"null","pinned":false},{"value":"The strength of Mr. Venkatarami Reddy lies in his ability to adapt and embed his knowledge into various real world problems with his research ability. The same has done under my guidance as well, embedded machine learning in predicting protein structures using Deep Learning techniques.","recorded":"2024-10-10 14:57:19.428796595","filePath":"null","pinned":false},{"value":"I've known Mr. Venkatarami Reddy Chaganti for the past 9 months. He worked as a research assistant under my supervision. I asked him to work on a research topic of his interest and he choose AI and it's working in various fields. \nHe chose the project titled \"Court Judgement Prediction and Recommendation\"\nBeing impressed by his research work, I gave him an opportunity to work as a full time research assistant under my guidance.\n\nDuring his project I noticed that he has always been very passionate about learning new things and tried implementing them. He always completed the task in the given time. He has an eye to detail and is fastidious about the results for every minor task that he does.\n\nOne of the most important and unique quality that I've observed in Venkat Is time management and his arduous zeal to finish the given task on time with accuracy. \n\nExamples: 1) Submission of multiple manuscripts on time for the conference \n2) Conducting research and creating pipelines accurately and precisely in given time.\n\nHe has submitted 4 research manuscripts within this span of 9-10 months and Not just restricted to a single domain, he worked on various domains and he  always wants to understand the usage of a domain in multiple domains, such as incorporating AI in law and Reinforcement learning in traffic signals and also AI In Computational Biology.  This shows his quest to knowledge and consistency which makes him unique.\n\nIn this tenure there has always been an exponential growth in both his academic performance and research work managing both equally.\n\nHe always wants to take the research work to the next level in an advanced way , \nbut due to limited resources \u0026 limited guidance he faces small obstacles that hinders him from achieving great things.\n\nI believe Computer Science course work at your esteemed institution and advanced facilities helps him to hone his skills.","recorded":"2024-10-10 14:33:58.874633602","filePath":"null","pinned":false},{"value":"I take the opportunity to write this letter to support Mr. Venkatarami Reddy Chaganti to pursue his master’s at your esteemed university. I am a professor at the Computer Science department at Indian Institute of Information Technology Sonepat. I have taught several students in my 9 years of experience, and I confidently say that Venkat is one of the brightest among them. I have known him for the past 4 years, during which I taught him Computer Programming, DBMS, Data Structures, Software Engineering, Soft Computing. I have also mentored him during his Smart Indian Hackathon 2023 and two of his major final year projects. During this time, I observed Venkat picking a team of students with relevant skills to get the job done. This unique skill, combined with his academic brilliance, helped him complete the projects quickly and efficiently. \n\nFrom an academic perspective, Venkat is a gold medalist and a brilliant student with innate curiosity and a willingness to understand academic concepts by any means possible. These qualities helped him rank in the top 2% of his batch. This is a testament to his high academic caliber. I've seen Venkat be well prepared for lectures—completing pre-reads, being up to speed with course content, and completing assignments on time. His enthusiasm towards the subject has always made the class more interactive as he would ask questions and introduce discussions. His interpersonal skills allow him to get along with his peers. He illustrated eminent verbal articulation in the project seminar, which was an integral part of the course.\n\nDuring his second year he started AI \u0026 ML club.  His main intention was to share the profound knowledge that he has on AI \u0026 ML to his peers and his juniors. Initially, he did not get facilitated with enough resources \u0026 support. However, with an unwavering determination and commitment he formed a club \u0026 actively participated and engaged all the members of the club to participate in many hackathons. Not just restricted to active participation. He made his team win some of them. This shows his team work \u0026 excellent leadership skills. During these 4 years I've noticed he has developed overall not just academically but also personally. I had the privilege to recommend him to multiple internship positions.\n\nObserving Venkat over four years, I firmly believe that he has the potential to succeed in all of his future endeavors, both academically and professionally. His academic knowledge, perseverance, and attitude will ensure his ascent to greater heights. I am confident that he/she will be a valuable asset to your cohort. I would strongly recommend his candidature for the program at your esteemed university.","recorded":"2024-10-10 14:32:06.873296071","filePath":"null","pinned":false},{"value":"Certainly. The student’s proficiency in implementing and optimizing advanced machine learning models, along with their ability to apply techniques like transfer learning, highlights their strong technical and problem-solving skills. They pay close attention to detail in improving model performance and accuracy, which reflects their analytical mindset. ","recorded":"2024-10-10 14:31:01.220676018","filePath":"null","pinned":false},{"value":"I have seen significant growth in Venkatarami’s ability to tackle interdisciplinary problems, blending his knowledge of machine learning with computational biology. His technical depth and understanding of advanced models have matured throughout our collaboration, as evidenced by his innovative solutions to complex biological challenges.","recorded":"2024-10-10 14:30:25.875194023","filePath":"null","pinned":false},{"value":"I would highlight Venkatarami’s problem-solving skills, as demonstrated by his ability to improve model performance and integrate complex datasets. ","recorded":"2024-10-10 14:30:05.042907396","filePath":"null","pinned":false},{"value":"Would you be able to provide examples to support the key skills the student plans to emphasize in their application? Certainly. Venkatarami’s proficiency in implementing and optimizing deep learning models for biological data, his use of transfer learning, and his attention to detail in model performance metrics are all excellent examples of his technical and problem-solving skills. His leadership in managing a lab and his collaborative efforts with peers demonstrate his ability to work in a team-oriented research environment, which he plans to highlight in his application.","recorded":"2024-10-10 14:29:37.105899628","filePath":"null","pinned":false},{"value":"Strengthening his statistical knowledge would further enhance his research capabilities, especially in fields requiring rigorous validation and testing.","recorded":"2024-10-10 14:28:59.542457827","filePath":"null","pinned":false},{"value":"which has practical applications in bioinformatics and drug development. His initiative to submit this work to a prestigious journal further underscores his dedication to advancing knowledge in the field.","recorded":"2024-10-10 14:28:13.779178443","filePath":"null","pinned":false},{"value":"Yes, his work on protein structure prediction using deep learning, specifically with CNNs and transformer-based models, would certainly stand out. He achieved high precision and ","recorded":"2024-10-10 14:28:00.298402300","filePath":"null","pinned":false},{"value":"    1. Can you recall any specific examples of the student's strengths in your class or projects?\n\n    2. How has the student demonstrated leadership, critical thinking, or problem-solving in your course?\n\n    3. What qualities do you think graduate admissions committees value most, and how does the student compare?\n\n    4. How does the student's academic performance align with the requirements of the program they're applying to?\n \n    5. Are there any examples of the student's work that you believe would stand out to an admissions committee?\n\n    6. What specific traits, like problem-solving or teamwork, would you highlight in the student's recommendation?\n\n    7. Where have you seen the most academic or professional growth in the student?\n\n    8. What areas should the student work on before starting this program?\n\n    9. How do the student's goals align with the work you’ve seen them do in your class?\n\n    10. Would you be able to provide examples to support the key skills the student plans to emphasize in their application?\n","recorded":"2024-10-10 14:19:27.351344754","filePath":"null","pinned":false},{"value":"It is a pleasure to write a recommendation for a student as dynamic and bright as Venkatarami Reddy Chaganti. I have had the privilege of evaluating his work as an advisor for his undergraduate final-year project. I taught him Machine Learning, Deep Learning, and Computational Biology in UG's 3rd and 4th years.  Throughout our association, I have witnessed his unwavering passion for his studies. His academic performance in our college is a testament to his excellence and his potential to excel in the MS in Computer Science.\nVenkatarami is a person who can combine knowledge and diligence to accomplish his goals. He is a keen student with high level of acumen and has a good grasp of his subjects. He is highly motivated and is always on the lookout to learn something new. Venkatarami is receptive to new ideas. He can work well in a team and has been managing the computational biology laboratory proficiently since last two years.\nFurthermore, Venkatarami developed and trained advanced deep learning models using convolutional neural networks (CNNs), recurrent neural networks (RNNs), and transformer-based models. He employed techniques like transfer learning and data augmentation to enhance the performance and accuracy of these models. His efforts led to high precision in predicting protein structures, reflecting his deep understanding of machine learning algorithms and computational biology principles.  Venkatarami's final product, notable for its accuracy and user-friendly interface, has significant practical applications in bioinformatics and drug development. He is now preparing to submit it to a prestigious journal, highlighting his commitment to contributing to the field through scholarly research.  \nBased on his excellent academic performance and well-honed interpersonal skills, I am confident that Mr. Venkatarami Reddy Chaganti will not only meet but also surpass your expectations. Therefore, I strongly recommend him for graduate studies at your university and financial assistance in the form of a research assistantship. I am certain he will be a source of pride for your institution.   ","recorded":"2024-10-10 14:17:42.444380643","filePath":"null","pinned":false},{"value":"sir what about the mail?","recorded":"2024-10-10 14:08:53.810105481","filePath":"null","pinned":false},{"value":"/mnt/Karna/Git/Masters-Documents/Applications/Certificates BTech/CMM.pdf","recorded":"2024-10-10 13:45:20.125020557","filePath":"null","pinned":false},{"value":"ASU ID: 1236373673","recorded":"2024-10-10 13:42:12.437698105","filePath":"null","pinned":false},{"value":"transcripts@asu.edu","recorded":"2024-10-10 13:41:53.969405003","filePath":"null","pinned":false},{"value":"Can you recall any specific examples of the student's strengths in your class or projects?","recorded":"2024-10-10 12:55:57.286988587","filePath":"null","pinned":false},{"value":"    1. Can you recall any specific examples of the student's strengths in your class or projects?\n\n    2. How has the student demonstrated leadership, critical thinking, or problem-solving in your course?\n\n    3. What qualities do you think graduate admissions committees value most, and how does the student compare?\n\n    4. How does the student's academic performance align with the requirements of the program they're applying to?\n \n    5. Are there any examples of the student's work that you believe would stand out to an admissions committee?\n\n    6. What specific traits, like problem-solving or teamwork, would you highlight in the student's recommendation?\n\n    7. Where have you seen the most academic or professional growth in the student?\n\n    8. What areas should the student work on before starting this program?\n\n    9. How do the student's goals align with the work you’ve seen them do in your class?\n\n    10. Would you be able to provide examples to support the key skills the student plans to emphasize in their application?","recorded":"2024-10-10 12:45:11.895827843","filePath":"null","pinned":false},{"value":"known","recorded":"2024-10-10 12:43:00.213948367","filePath":"null","pinned":false},{"value":"I have had the privilege of evaluating his work as an advisor for his undergraduate final-year project.","recorded":"2024-10-10 12:37:03.802921821","filePath":"null","pinned":false},{"value":"I've known Mr. Venkatarami Reddy Chaganti for the past 9 months. He worked as a research assistant under my supervision.","recorded":"2024-10-10 12:36:21.374666062","filePath":"null","pinned":false},{"value":"LOR – 2 Mann Sir","recorded":"2024-10-10 12:24:33.253439128","filePath":"null","pinned":false},{"value":"Observing XXXX over four years, I firmly believe that he/she has the potential to succeed in all of his/her future endeavors, both academically and professionally. His/Her academic knowledge, perseverance, and attitude will ensure his/her ascent to greater heights. I am confident that he/she will be a valuable asset to your cohort. I would strongly recommend his/her candidature for the program at your esteemed university.","recorded":"2024-10-10 12:23:27.316832739","filePath":"null","pinned":false},{"value":"During these 4 years I've noticed he has developed overall not just academically but also personally. I had the privilege to recommend him to multiple internship positions.","recorded":"2024-10-10 12:18:19.067274552","filePath":"null","pinned":false},{"value":"This shows his team work \u0026 excellent leadership skills","recorded":"2024-10-10 12:18:13.680667210","filePath":"null","pinned":false},{"value":"During his second year he started AI \u0026 ML club. \nHis main intention was to share the profound knowledge that he has on AI \u0026 ML to his peers and his juniors.\n\nInitially, he did not get facilitated with enough resources \u0026 support.\nHowever, with an unwavering determination and commitment he formed a club \u0026 actively participated and engaged all the members of the club to participate in many hackathons.\nNot just restricted to active participation. He made his team win many hackathons.","recorded":"2024-10-10 12:17:59.516196225","filePath":"null","pinned":false},{"value":"From an academic perspective, Venkat is a gold medalist and a brilliant student with innate curiosity and a willingness to understand academic concepts by any means possible. These qualities helped him rank in the top 5% of his batch. This is a testament to his high academic caliber. I've seen Venkat be well prepared for lectures—completing pre-reads, being up to speed with course content, and completing assignments on time. His enthusiasm towards the subject has always made the class more interactive as he would ask questions and introduce discussions. His interpersonal skills allow him to get along with his peers. He illustrated eminent verbal articulation in the project seminar, which was an integral part of the course.","recorded":"2024-10-10 12:06:38.744252873","filePath":"null","pinned":false},{"value":"I take the opportunity to write this letter to support Mr. Venkatarami Reddy Chaganti to pursue his master’s at your esteemed university. I am a professor at the Computer Science department at Indian Institute of Information Technology Sonepat. I have taught several students in my 9 years of experience, and I confidently say that Venkat is one of the brightest among them. I have known him for the past 4 years, during which I taught him Computer Programming, DBMS, Data Structures, Software Engineering, Soft Computing. I have also mentored him during his Smart Indian Hackathon 2023 and two of his major final year projects. During this time, I observed Venkat picking a team of students with relevant skills to get the job done. This unique skill, combined with his academic brilliance, helped him complete the projects quickly and efficiently. ","recorded":"2024-10-10 12:04:30.458736208","filePath":"null","pinned":false},{"value":" LOR – 1 Rakesh Sir","recorded":"2024-10-10 11:55:23.365785403","filePath":"null","pinned":false},{"value":"Not just restricted to a single domain, he worked on various domains ","recorded":"2024-10-10 11:54:10.384414976","filePath":"null","pinned":false},{"value":"I've known venkat for the past 9 months. He worked as a research assistant under my supervision. I asked him to work on a research topic of his interest and he choose AI and it's working in various fields. \nHe chose the project titled \" \"\nBeing impressed by his research work, I gave him an opportunity to work as a full time research assistant under my guidance.\n\n\nDuring his project I noticed that he has always been very passionate about learning new things and tried implementing them. He always completed the task in the given time. He has an eye to detail and is fastidious about the results for every minor task that he does.\n\nOne of the most important quality that I've observed in VRR\nIs time management and his arduous zeal to finish the given task on time with accuracy. \nEg's\n\n\nHe has submitted 4 research papers on various topics like :\n1.\n2.\n3.\nNot just restricted to a single domain, he worked on various domains \n\nThis shows his quest to knowledge and consistency which makes him unique.\n\nIn this 9 months there has always been an exponential growth in both his academic performance and research work managing both equally.\n\nHe always wants to take the research work to the next level in an advanced way , \nbut due to limited resources \u0026 limited guidance he faces small obstacles that hinders him from achieving great things.\nI believe XYZ course work at your esteemed institution and advanced facilities helps him to hone his skills.","recorded":"2024-10-10 11:46:53.979828630","filePath":"null","pinned":false},{"value":"https://meet.google.com/kju-thvw-pze","recorded":"2024-10-10 10:38:13.959460561","filePath":"null","pinned":false}]}