#+title: Pandas Important Points & Basics

*** Creating a Series by passing a list of values, letting pandas create a default integer index:

#+begin_src python :results drawer output :exports both :wrap example
import pandas as pd
import numpy as np

s = pd.Series([1, 3, 5, np.nan, 6, 8])

print(s)
#+end_src

#+RESULTS:
#+begin_example
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
#+end_example

*** Creating a DataFrame by passing a NumPy array, with a datetime index and labeled columns:

#+begin_src python :results drawer output :exports both :wrap example
import numpy as np
import pandas as pd

dates = pd.date_range("20130101", periods=6)
print(dates)
print('\n\n')

print("Pandas DataFrame")
df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list("ABCD"))
print(df)
#+end_src

#+RESULTS:
#+begin_example
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')



Pandas DataFrame
                   A         B         C         D
2013-01-01 -1.172585  0.389941  0.453800  1.154620
2013-01-02 -0.307738 -1.262066  0.419675 -1.262085
2013-01-03  1.046099 -0.411504  0.424565  1.225648
2013-01-04 -0.029517 -0.792038 -0.097531  0.275425
2013-01-05  0.610102  0.000608  0.137623  1.188012
2013-01-06 -0.921044  0.448201 -1.883159 -1.449910
#+end_example

*** Creating a DataFrame by passing a dictionary of objects that can be converted into a series-like structure:

#+begin_src python :wrap example :results drawer output :exports both
import pandas as pd
import numpy as np

df = pd.DataFrame(
    {
        "A": 1.0,
        "B": pd.Timestamp("20130102"),
        "C": pd.Series(1, index=list(range(4)), dtype="float32"),
        "D": np.array([3] * 4, dtype="int32"),
        "E": pd.Categorical(["test", "train", "test", "train"]),
        "F": "foo",
    }
)

print(df)
print('\n')
print(df.dtypes , '\n')
print(df.index, '\n')
print(df.to_numpy(), '\n\n')
print(df.describe(), '\n\n')

## Axis = 0 ==> Rows(Index)
## Axis = 1 ==> Columns
print(df.sort_index(axis=0, ascending=True), '\n')

df['G'] = ["A", "B", "C", "A"]

## Using the isin() method for filtering:
print(df['G'].isin(["A", "B"]))
print(df[df['G'].isin(["A", "B"])])
#+end_src

#+RESULTS:
#+begin_example
     A          B    C  D      E    F
0  1.0 2013-01-02  1.0  3   test  foo
1  1.0 2013-01-02  1.0  3  train  foo
2  1.0 2013-01-02  1.0  3   test  foo
3  1.0 2013-01-02  1.0  3  train  foo


A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object

Int64Index([0, 1, 2, 3], dtype='int64')

[[1.0 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo']
 [1.0 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo']
 [1.0 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo']
 [1.0 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo']]


         A    C    D
count  4.0  4.0  4.0
mean   1.0  1.0  3.0
std    0.0  0.0  0.0
min    1.0  1.0  3.0
25%    1.0  1.0  3.0
50%    1.0  1.0  3.0
75%    1.0  1.0  3.0
max    1.0  1.0  3.0


     A          B    C  D      E    F
0  1.0 2013-01-02  1.0  3   test  foo
1  1.0 2013-01-02  1.0  3  train  foo
2  1.0 2013-01-02  1.0  3   test  foo
3  1.0 2013-01-02  1.0  3  train  foo

0     True
1     True
2    False
3     True
Name: G, dtype: bool
     A          B    C  D      E    F  G
0  1.0 2013-01-02  1.0  3   test  foo  A
1  1.0 2013-01-02  1.0  3  train  foo  B
3  1.0 2013-01-02  1.0  3  train  foo  A
#+end_example

*** Setting a new column automatically aligns the data by the indexes:

#+begin_src python :exports both :results drawer output :wrap example
import numpy as np
import pandas as pd

dates = pd.date_range("20220501", periods=6)
s1 = pd.DataFrame(np.random.randn(6, 4), index=dates)
s1.columns = ("A", "B", "C", "D")
print("Before changing values \n\n", s1)
s1.at[dates[2], "D"] = 0
print("\n\nAfter cahnging the value of D at dates[2] = 0 \n\n",s1)
#+end_src

#+RESULTS:
#+begin_example
Before changing values

                    A         B         C         D
2022-05-01  0.612673 -0.001135  0.284124  0.801494
2022-05-02 -0.019266  0.974093  1.986471 -1.533315
2022-05-03 -0.683853  0.982893  0.611900 -1.061332
2022-05-04 -0.360594 -0.779629 -0.023391 -0.267447
2022-05-05  0.362789 -1.992307 -0.754424  1.946700
2022-05-06  0.475255 -1.427635 -0.761617  0.484237


After cahnging the value of D at dates[2] = 0

                    A         B         C         D
2022-05-01  0.612673 -0.001135  0.284124  0.801494
2022-05-02 -0.019266  0.974093  1.986471 -1.533315
2022-05-03 -0.683853  0.982893  0.611900  0.000000
2022-05-04 -0.360594 -0.779629 -0.023391 -0.267447
2022-05-05  0.362789 -1.992307 -0.754424  1.946700
2022-05-06  0.475255 -1.427635 -0.761617  0.484237
#+end_example

*** DataFrame has the methods add(), sub(), mul(), div() and related functions radd(), rsub(), ... for carrying out binary operations. For broadcasting behavior, Series input is of primary interest. Using these functions, you can use to either match on the index or columns via the axis keyword

#+begin_src python :exports both :results drawer output :wrap example
import numpy as np
import pandas as pd

np.random.seed(42) # This will stop random numbers to stay after 42 times changing and keep them constant
df = pd.DataFrame(
    {
        "one": pd.Series(np.random.randn(3), index=["a", "b", "c"]),
        "two": pd.Series(np.random.randn(4), index=["a", "b", "c", "d"]),
        "three": pd.Series(np.random.randn(3), index=["b", "c", "d"]),
    }
)

print(df,'\n')

row = df.iloc[1] # This will locate whole 1st row

column = df["two"]
print(df.sub(row, axis="columns")) # It subtracts row 1 from every column with respect to each column
# You can also takes axis = 1 since 0 ==> rows and 1 ==> columns

#+end_src

#+RESULTS:
#+begin_example
        one       two     three
a  0.496714  1.523030       NaN
b -0.138264 -0.234153  0.767435
c  0.647689 -0.234137 -0.469474
d       NaN  1.579213  0.542560

        one       two     three
a  0.634978  1.757183       NaN
b  0.000000  0.000000  0.000000
c  0.785953  0.000016 -1.236909
d       NaN  1.813366 -0.224875
#+end_example

*** Series and Index also support the divmod() builtin. This function takes the floor division and modulo operation at the Series and Index also support the divmod() builtin. This function takes the floor division and modulo operation at the

#+begin_src python :exports both :wrap example :results drawer output
import pandas as pd
import numpy as np

s = pd.Series(np.arange(10))
print(s, '\n')

div, rem = divmod(s, 3)
print("Quotient\n")
print(div)
print("\nRemainder\n")
print(rem, '\n')

# We can also do elementwise divmod():
# div, rem = divmod(s, [2, 2, 3, 3, 4, 4, 5, 5, 6, 6])

#+end_src

#+RESULTS:
#+begin_example
0    0
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8
9    9
dtype: int64

Quotient

0    0
1    0
2    0
3    1
4    1
5    1
6    2
7    2
8    2
9    3
dtype: int64

Remainder

0    0
1    1
2    2
3    0
4    1
5    2
6    0
7    1
8    2
9    0
dtype: int64

#+end_example

*** The pandas I/O API is a set of top level reader functions accessed like pandas.read_csv() that generally return a pandas object. The corresponding writer functions are object methods that are accessed like DataFrame.to_csv().

*** Below is a table containing available readers and writers.

#+CAPTION: IO Tools in Pandas
[[images/IO Tools.png]]
